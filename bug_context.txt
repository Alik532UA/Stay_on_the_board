==== START OF FILE: src/lib/stores/settingsStore.ts ====
import { writable, get } from 'svelte/store';
import { loadAndGetVoices, filterVoicesByLang } from '$lib/services/speechService.js';
import { openVoiceSettingsModal } from '$lib/stores/uiStore.js';
import { locale } from 'svelte-i18n';
import { modalStore } from '$lib/stores/modalStore.js';
import { gameState } from './gameState';
import { logService } from '../services/logService.js';

export type KeybindingAction = 'up'|'down'|'left'|'right'|'up-left'|'up-right'|'down-left'|'down-right'|'confirm'|'no-moves'|'toggle-block-mode'|'toggle-board'|'increase-board'|'decrease-board'|'toggle-speech'|'distance-1'|'distance-2'|'distance-3'|'distance-4'|'distance-5'|'distance-6'|'distance-7'|'distance-8';

const isBrowser = typeof window !== 'undefined';
const defaultStyle = import.meta.env.DEV ? 'gray' : 'purple';
const SETTINGS_VERSION = 2;

const defaultSettings: any = {
  version: SETTINGS_VERSION,
  showMoves: true,
  showBoard: true,
  language: 'uk',
  theme: 'dark',
  style: defaultStyle,
  speechEnabled: false,
  selectedVoiceURI: null,
  blockModeEnabled: false,
  showPiece: true,
  blockOnVisitCount: 0,
  autoHideBoard: false,
  keybindings: {
    'up-left': ['Numpad7', 'KeyQ'],
    'up': ['Numpad8', 'KeyW'],
    'up-right': ['Numpad9', 'KeyE'],
    'left': ['Numpad4', 'KeyA'],
    'right': ['Numpad6', 'KeyD'],
    'down-left': ['Numpad1', 'KeyZ'],
    'down': ['Numpad2', 'KeyX'],
    'down-right': ['Numpad3', 'KeyC'],
    'confirm': ['Numpad5', 'Enter', 'Space'],
    'no-moves': ['NumpadDecimal', 'Backspace'],
    'distance-1': ['Digit1'],
    'distance-2': ['Digit2'],
    'distance-3': ['Digit3'],
    'distance-4': ['Digit4'],
    'distance-5': ['Digit5'],
    'distance-6': ['Digit6'],
    'distance-7': ['Digit7'],
    'distance-8': ['Digit8'],
    'toggle-block-mode': ['NumpadMultiply', 'KeyB'],
    'toggle-board': ['NumpadDivide', 'KeyH'],
    'increase-board': ['NumpadAdd', 'Equal'],
    'decrease-board': ['NumpadSubtract', 'Minus'],
    'toggle-speech': ['KeyS'],
  },
  keyConflictResolution: {},
  gameMode: null,
  rememberGameMode: false,
  showGameModeModal: true,
  showDifficultyWarningModal: true,
  showGameInfoWidget: 'shown',
  lockSettings: false,
  testMode: false,
};

/**
 * @template T
 * @param {string | null} jsonString
 * @param {T} defaultValue
 * @returns {T}
 */
function safeJsonParse<T>(jsonString: string | null, defaultValue: T): T {
  if (!jsonString) return defaultValue;
  try {
    const parsed = JSON.parse(jsonString);
    return parsed;
  } catch (e) {
    return defaultValue;
  }
}

/**
 * @param {string|null} style
 * @returns {string|null}
 */
const convertStyle = (style: string | null): string | null => {
  if (!style) return null;
  const conversions: { [key: string]: string } = { 'ubuntu': 'purple', 'peak': 'green', 'cs2': 'blue', 'glass': 'gray', 'material': 'orange' };
  return conversions[style] || style;
};

function loadSettings(): any {
  if (!isBrowser) return defaultSettings;

  try {
    const storedSettingsRaw = localStorage.getItem('settings');
    const sessionGameMode = isBrowser ? sessionStorage.getItem('gameMode') : null;
    logService.init('Завантажено raw налаштування з localStorage:', storedSettingsRaw);
    const storedSettings: { version?: number; keybindings?: Record<string, string[]> } = safeJsonParse(storedSettingsRaw, {});
    logService.init('Розпарсені налаштування:', storedSettings);
    const settingsVersion = storedSettings.version || 0;

    let mergedSettings = { ...defaultSettings, ...storedSettings };

    if (settingsVersion < SETTINGS_VERSION) {
      const defaultKeybindings = defaultSettings.keybindings;
      const storedKeybindings = storedSettings.keybindings || {};
      
      const mergedKeybindings = { ...defaultKeybindings };

      for (const action in defaultKeybindings) {
        if (storedKeybindings[action]) {
          const uniqueKeys = [...new Set([...defaultKeybindings[action], ...storedKeybindings[action]])];
          mergedKeybindings[action] = uniqueKeys;
        }
      }
       for (const action in storedKeybindings) {
        if (!mergedKeybindings[action]) {
          mergedKeybindings[action] = storedKeybindings[action];
        }
      }

      mergedSettings.keybindings = mergedKeybindings;
      mergedSettings.version = SETTINGS_VERSION;
    }
    
    const legacyKeybindingsRaw = localStorage.getItem('keybindings');
    if (legacyKeybindingsRaw) {
        const legacyKeybindings: Record<string, string[]> = safeJsonParse(legacyKeybindingsRaw, {});
        for (const action in legacyKeybindings) {
            if (mergedSettings.keybindings[action]) {
                const uniqueKeys = [...new Set([...mergedSettings.keybindings[action], ...legacyKeybindings[action]])];
                mergedSettings.keybindings[action] = uniqueKeys;
            } else {
                mergedSettings.keybindings[action] = legacyKeybindings[action];
            }
        }
        localStorage.removeItem('keybindings');
    }

    // Ensure all keybindings are arrays
    Object.keys(mergedSettings.keybindings).forEach(action => {
      const key = action as keyof typeof mergedSettings.keybindings;
      if (typeof mergedSettings.keybindings[key] === 'string') {
        // @ts-ignore
        mergedSettings.keybindings[key] = [mergedSettings.keybindings[key]];
      }
    });

    const gameMode = mergedSettings.gameMode;
    mergedSettings.gameMode = ['beginner', 'experienced', 'pro'].includes(gameMode) ? gameMode : sessionGameMode;
    
    // Migrate individual settings from localStorage to the new 'settings' object
    const individualSettingsMap = {
      showMoves: 'showMoves',
      showBoard: 'showBoard',
      lang: 'language',
      theme: 'theme',
      style: 'style',
      speechEnabled: 'speechEnabled',
      selectedVoiceURI: 'selectedVoiceURI',
      blockModeEnabled: 'blockModeEnabled',
      showPiece: 'showPiece',
      blockOnVisitCount: 'blockOnVisitCount',
      autoHideBoard: 'autoHideBoard',
      keyConflictResolution: 'keyConflictResolution',
      gameMode: 'gameMode',
      rememberGameMode: 'rememberGameMode',
      showGameModeModal: 'showGameModeModal',
      showDifficultyWarningModal: 'showDifficultyWarningModal',
      showGameInfoWidget: 'showGameInfoWidget',
      lockSettings: 'lockSettings',
      testMode: 'testMode'
    };

    let hasMigrated = false;
    for (const [storageKey, settingsKey] of Object.entries(individualSettingsMap)) {
      const storedValue = localStorage.getItem(storageKey);
      if (storedValue !== null) {
        hasMigrated = true;
        switch (settingsKey) {
          case 'showMoves':
          case 'showBoard':
          case 'speechEnabled':
          case 'blockModeEnabled':
          case 'showPiece':
          case 'autoHideBoard':
          case 'showGameModeModal':
          case 'rememberGameMode':
          case 'showDifficultyWarningModal':
          case 'lockSettings':
          case 'testMode':
            // @ts-ignore
            mergedSettings[settingsKey] = storedValue === 'true';
            break;
          case 'blockOnVisitCount':
            // @ts-ignore
            mergedSettings[settingsKey] = Number(storedValue);
            break;
          case 'style':
            mergedSettings.style = convertStyle(storedValue) || defaultSettings.style;
            break;
          case 'keyConflictResolution':
            mergedSettings.keyConflictResolution = safeJsonParse(storedValue, {});
            break;
          default:
            // @ts-ignore
            mergedSettings[settingsKey] = storedValue;
        }
        localStorage.removeItem(storageKey);
      }
    }

    if (hasMigrated) {
      localStorage.setItem('settings', JSON.stringify(mergedSettings));
    }

    return mergedSettings;

  } catch (error) {
    logService.init('Помилка завантаження налаштувань:', error);
    return defaultSettings;
  }
}

function createSettingsStore() {
  const { subscribe, set, update } = writable<any>(loadSettings());

  const methods = {
    init: () => {
      try {
        if (isBrowser) {
          const settings = loadSettings();
          set(settings);
          subscribe(currentSettings => {
            document.documentElement.setAttribute('data-theme', currentSettings.theme);
            document.documentElement.setAttribute('data-style', currentSettings.style);
          });
        }
        logService.init('settingsStore ініціалізовано успішно');
      } catch (error) {
        logService.init('Помилка ініціалізації settingsStore:', error);
        set(defaultSettings);
      }
    },
    updateSettings: (newSettings: Partial<any>) => {
      update((state: any) => {
          const merged = { ...state, ...newSettings };
          logService.state('Оновлення налаштувань. Поточний стан:', state);
          logService.state('Нові налаштування:', newSettings);
          logService.state('Об\'єднані налаштування:', merged);
          if (isBrowser) {
            const persistentState = { ...merged };
            
            if (merged.rememberGameMode) {
              persistentState.gameMode = merged.gameMode;
            } else {
              persistentState.gameMode = null;
            }
  
            if (isBrowser && merged.gameMode) {
              sessionStorage.setItem('gameMode', merged.gameMode);
            } else if (isBrowser) {
              sessionStorage.removeItem('gameMode');
            }
  
            logService.state('Стан для збереження в localStorage:', persistentState);
            localStorage.setItem('settings', JSON.stringify(persistentState));
          }
          return merged;
        });
    },
    setVisibilityLevel: (level: number) => {
      let newSettings: Partial<any> = {};
      switch (level) {
        case 1: newSettings = { showBoard: false, showPiece: false, showMoves: false }; break;
        case 2: newSettings = { showBoard: true, showPiece: false, showMoves: false }; break;
        case 3: newSettings = { showBoard: true, showPiece: true, showMoves: false }; break;
        case 4: newSettings = { showBoard: true, showPiece: true, showMoves: true }; break;
      }
      methods.updateSettings(newSettings);
    },
    resetSettings: () => {
      if (isBrowser) {
        localStorage.removeItem('settings');
      }
      set(defaultSettings);
    },
    resetKeybindings: () => {
      methods.updateSettings({ keybindings: defaultSettings.keybindings });
    },
    /**
     * @param {string} key
     * @param {KeybindingAction} action
     */
    /**
     * @param {string} key
     * @param {KeybindingAction} action
     */
    resolveKeyConflict: (key: string, action: KeybindingAction) => {
      update((state: any) => {
        const newResolution = { ...state.keyConflictResolution, [key]: action };
        if (isBrowser) {
          localStorage.setItem('keyConflictResolution', JSON.stringify(newResolution));
        }
        return { ...state, keyConflictResolution: newResolution };
      });
    },
    toggleShowBoard: (forceState: boolean | undefined) => {
      update((state: any) => {
        const newState = typeof forceState === 'boolean' ? forceState : !state.showBoard;
        const newSettings = { ...state, showBoard: newState };
        if (isBrowser) {
          localStorage.setItem('showBoard', String(newSettings.showBoard));
        }
        return newSettings;
      });
    },
    toggleShowMoves: () => {
      update(state => {
        const newState = !state.showMoves;
        if (isBrowser) localStorage.setItem('showMoves', String(newState));
        return { ...state, showMoves: newState };
      });
    },
    toggleShowPiece: () => {
      update(state => {
        const newShowPieceState = !state.showPiece;
        const newSettings = { ...state, showPiece: newShowPieceState };
        if (!newShowPieceState) {
          newSettings.showMoves = false;
        }
        if (isBrowser) {
          localStorage.setItem('showPiece', String(newSettings.showPiece));
          if (!newShowPieceState) {
            localStorage.setItem('showMoves', String(newSettings.showMoves));
          }
        }
        return newSettings;
      });
    },
    toggleAutoHideBoard: () => {
      update(state => {
        const newState = !state.autoHideBoard;
        if (isBrowser) localStorage.setItem('autoHideBoard', String(newState));
        return { ...state, autoHideBoard: newState };
      });
    },
    setGameInfoWidgetState: (newState: 'hidden' | 'shown' | 'compact') => {
      update((state: any) => {
        if (isBrowser) localStorage.setItem('showGameInfoWidget', newState);
        return { ...state, showGameInfoWidget: newState };
      });
    },
    toggleBlockMode: () => {
      update((state: any) => {
        const newState = !state.blockModeEnabled;
        if (isBrowser) localStorage.setItem('blockModeEnabled', String(newState));
        if (newState) {
          gameState.update(gs => {
            const resetHistoryEntry = {
              pos: { row: gs.playerRow, col: gs.playerCol },
              blocked: [] as {row: number, col: number}[],
              visits: {},
              blockModeEnabled: newState
            };
            return {
              ...gs,
              cellVisitCounts: {},
              movesInBlockMode: 0,
              moveHistory: [...gs.moveHistory, resetHistoryEntry]
            };
          });
        }
        return { ...state, blockModeEnabled: newState };
      });
    },
    toggleSpeech: async (desiredState?: boolean) => {
      const currentState = get(settingsStore);
      const isEnabled = typeof desiredState === 'boolean' ? desiredState : !currentState.speechEnabled;
      if (!isEnabled) {
        methods.updateSettings({ speechEnabled: false });
        return;
      }
      const allVoices = await loadAndGetVoices();
      const currentLocale = get(locale) || 'uk';
      const availableVoices = filterVoicesByLang(allVoices, currentLocale);
      const hasConfiguredSpeech = isBrowser && localStorage.getItem('hasConfiguredSpeech') === 'true';
      if (availableVoices.length > 0) {
        if (!hasConfiguredSpeech) {
          openVoiceSettingsModal();
          if (isBrowser) localStorage.setItem('hasConfiguredSpeech', 'true');
        }
        methods.updateSettings({ speechEnabled: true });
      } else {
        openVoiceSettingsModal();
        methods.updateSettings({ speechEnabled: false });
      }
    },
    /**
     * @param {'beginner' | 'experienced' | 'pro'} mode
     * @returns {boolean}
     */
    /**
     * @param {'beginner' | 'experienced' | 'pro'} mode
     * @param {any} [modal=modalStore]
     * @returns {boolean}
     */
    applyGameModePreset: (mode: 'beginner' | 'experienced' | 'pro', modal = modalStore) => {
      let settingsToApply: Partial<any> = {};
      let showFaq = false;
      switch (mode) {
        case 'beginner':
          settingsToApply = { showBoard: true, showPiece: true, showMoves: true, showGameInfoWidget: 'shown', blockModeEnabled: false, speechEnabled: false, autoHideBoard: false };
          showFaq = true;
          break;
        case 'experienced':
          settingsToApply = { showBoard: true, showPiece: true, showMoves: true, showGameInfoWidget: 'shown', blockModeEnabled: false, speechEnabled: true, autoHideBoard: true };
          break;
        case 'pro':
          settingsToApply = { showBoard: true, showPiece: true, showMoves: true, showGameInfoWidget: 'shown', blockModeEnabled: true, blockOnVisitCount: 0, speechEnabled: true, autoHideBoard: true };
          break;
      }
      settingsToApply.gameMode = mode;
      if (modal === modalStore) {
        settingsToApply.rememberGameMode = get(settingsStore).showGameModeModal ? false : true;
      } else {
        settingsToApply.rememberGameMode = true;
      }
      methods.updateSettings(settingsToApply);
      modal.closeModal();
      return showFaq;
    },
    toggleTestMode: () => {
      update(state => {
        const newState = !state.testMode;
        if (isBrowser) localStorage.setItem('testMode', String(newState));
        return { ...state, testMode: newState };
      });
    },
  };
  return { subscribe, ...methods };
}

export const settingsStore = createSettingsStore();

==== END OF FILE: src/lib/stores/settingsStore.ts ====


==== START OF FILE: src/lib/stores/uiEffectsStore.ts ====
import { writable, get } from 'svelte/store';
import { settingsStore } from './settingsStore.js';

/**
 * Store для централізованого керування побічними ефектами UI (таймери, затримки, автоприховування тощо).
 */

function createUiEffectsStore() {
  let autoHideTimeout: ReturnType<typeof setTimeout> | null = null;

  /**
   * Автоматично приховати дошку після зміни позиції фігури.
   * @param delayMs - затримка у мілісекундах (за замовчуванням 0)
   */
  function autoHideBoard(delayMs = 0) {
    if (autoHideTimeout) clearTimeout(autoHideTimeout);
    autoHideTimeout = setTimeout(() => {
      if (get(settingsStore).showBoard) {
        settingsStore.toggleShowBoard(false);
      }
    }, delayMs);
  }

  return {
    autoHideBoard
  };
}

export const uiEffectsStore = createUiEffectsStore(); 

==== END OF FILE: src/lib/stores/uiEffectsStore.ts ====


==== START OF FILE: src/lib/components/widgets/BoardWrapperWidget.svelte ====
<!--
ВАЖЛИВО! Архітектурний принцип: пауза (затримка) після ходу гравця реалізується лише у візуалізації дошки (animationStore),
логіка гри та center-info оновлюються миттєво і не залежать від цієї паузи. Це гарантує SoC, SSoT, UDF.
-->
<script lang="ts">
  // ВАЖЛИВО! Заборонено напряму змінювати moveQueue або board з UI-компонента!
  // Компонент лише спостерігає за станом гри і ініціює анімацію через animationStore.
  // Всі зміни логіки гри — лише через оркестратор/сервіси.
  //
  // IMPORTANT: Never mutate moveQueue or board directly from UI! This component only observes state and triggers animation.
  import { gameState } from '$lib/stores/gameState.js';
  import { settingsStore } from '$lib/stores/settingsStore.js';

  import { modalStore } from '$lib/stores/modalStore.js';
  import SvgIcons from '../SvgIcons.svelte';
  import { safeScale } from '$lib/utils/transitions.ts';
  import { quintOut } from 'svelte/easing';
  import { isCellBlocked, getDamageClass } from '$lib/utils/boardUtils.ts';
  import { animationStore } from '$lib/stores/animationStore.js';
  import { visualPosition, visualCellVisitCounts, visualBoardState, currentPlayer, availableMoves } from '$lib/stores/derivedState.ts';
  import { derived } from 'svelte/store';
  import { get } from 'svelte/store';
  import { onMount } from 'svelte';
  import { uiEffectsStore } from '$lib/stores/uiEffectsStore.js';
  import BoardCell from './BoardCell.svelte';
  import PlayerPiece from './PlayerPiece.svelte';
  import { logService } from '$lib/services/logService.js';

  const boardSize = derived(gameState, $gameState => $gameState ? Number($gameState.boardSize) : 0);
  
  // Слідкуємо, чи був зроблений хід гравця (moveQueue останній елемент - player: 1)
  const shouldHideBoard = derived([
    settingsStore,
    gameState
  ], ([$settingsStore, $gameState]) => {
    if (!$gameState || !$settingsStore.autoHideBoard) return false;
    const lastMove = $gameState.moveQueue?.[$gameState.moveQueue.length - 1];
    return lastMove && lastMove.player === 1;
  });

  // --- Додаємо автозапуск чекбоксів перед першим ходом користувача ---
  // НАВІЩО: Гарантуємо, що всі візуальні опції (showBoard, showPiece, showMoves) будуть активовані для коректного UX при старті нової гри.
  function enableAllGameCheckboxesIfNeeded() {
    const s = get(settingsStore);
    let changed = false;
    if (!s.showBoard) { settingsStore.toggleShowBoard(true); changed = true; }
    if (!s.showPiece) { settingsStore.toggleShowPiece(); changed = true; }
    if (!s.showMoves) { settingsStore.toggleShowMoves(); changed = true; }
    // Якщо showPiece був вимкнений, showMoves міг автоматично вимкнутись, тому ще раз вмикаємо
    if (!get(settingsStore).showMoves) { settingsStore.toggleShowMoves(); }
  }

  onMount(() => {
    const unsubscribe = gameState.subscribe(($gameState) => {
      if (!$gameState) return;

      // НАВІЩО: Зберігаємо попередню позицію гравця для коректного визначення зміни стану та автоприховування дошки.
      let lastRow = $gameState.playerRow;
      let lastCol = $gameState.playerCol;

      // Вмикаємо чекбокси при старті нової гри
      if ($gameState.moveHistory.length === 1) {
        enableAllGameCheckboxesIfNeeded();
      }

      // НАВІЩО: Реакція на зміну позиції гравця для автоприховування дошки та повторного вмикання чекбоксів після скидання гри.
      if (
        get(settingsStore).autoHideBoard &&
        get(settingsStore).showBoard &&
        ($gameState.playerRow !== lastRow || $gameState.playerCol !== lastCol) &&
        $gameState.moveHistory.length > 1
      ) {
        lastRow = $gameState.playerRow;
        lastCol = $gameState.playerCol;
        uiEffectsStore.autoHideBoard(0);
      } else {
        lastRow = $gameState.playerRow;
        lastCol = $gameState.playerCol;
      }
      // --- Після автоприховування дошки ---
      // Вмикаємо чекбокси тільки після початку гри (є ходи в історії), а не при ініціалізації
      if ($gameState.moveQueue && $gameState.moveQueue.length === 0 && $gameState.moveHistory.length > 1) {
        enableAllGameCheckboxesIfNeeded();
      }
    });
    return unsubscribe;
  });

  let prevGameId: number|null = null;
  // Видаляємо prevMoveQueueLength, оскільки анімація тепер керується через animationStore
  // НАВІЩО: Відстежуємо зміну gameId для скидання стану при новій грі.
  gameState.subscribe(($gameState) => {
    if (!$gameState) {
      prevGameId = null;
      return;
    }
    // Якщо нова гра — скидаємо лічильник
    if ($gameState.gameId !== prevGameId) {
      prevGameId = $gameState.gameId;
      logService.ui('[BoardWrapperWidget] Нова гра, скидаємо стан');
    }
    // Анімація тепер керується через animationStore.visualMoveQueue
    // Не потрібно викликати animateLastMove тут
  });

  const showAvailableMoves = derived(
    [settingsStore, animationStore, currentPlayer],
    ([$settingsStore, $animationStore, $currentPlayer]) => {
      return (
        $settingsStore.showMoves &&
        !$animationStore.isAnimating &&
        $currentPlayer?.type === 'human' &&
        $animationStore.isComputerMoveCompleted
      );
    }
  );

  function getMoveInfo(row: number, col: number) {
    if (!$showAvailableMoves) {
      return { isAvailable: false, isPenalty: false };
    }

    const move = get(availableMoves).find(m => m.row === row && m.col === col);

    if (move) {
      return {
        isAvailable: true,
        isPenalty: move.isPenalty || false
      };
    }
    
    return { isAvailable: false, isPenalty: false };
  }

  function showBoardClickHint(e: Event) {
    if (e && typeof e.stopPropagation === 'function') e.stopPropagation();
    modalStore.showModal({
      titleKey: 'modal.boardClickTitle',
      contentKey: 'modal.boardClickContent',
      buttons: [{ textKey: 'modal.ok', primary: true, isHot: true }],
      dataTestId: 'board-click-modal'
    });
  }

  function onCellRightClick(event: MouseEvent, row: number, col: number): void {
    event.preventDefault();
    if ($gameState && $settingsStore.blockModeEnabled && !(row === $gameState.playerRow && col === $gameState.playerCol)) {
      const visualCounts = get(visualCellVisitCounts);
      const blocked = isCellBlocked(row, col, visualCounts, $settingsStore);
      logService.ui(`${blocked ? 'Розблокування' : 'Блокування'} клітинки [${row},${col}]`);
    }
  }

</script>

{#if $gameState}
  {#key $gameState.gameId}
    {#if $settingsStore.showBoard}
      <div
        class="board-bg-wrapper game-content-block{ $shouldHideBoard ? ' hidden' : '' }"
        style="--board-size: {$boardSize}"
        onclick={showBoardClickHint}
        onkeydown={(e) => (e.key === 'Enter' || e.key === ' ') && showBoardClickHint(e)}
        role="button"
        tabindex="0"
        aria-label="Ігрове поле"
        transition:safeScale={{ duration: 600, easing: quintOut }}
      >
        <div class="game-board" style="--board-size: {$boardSize}" role="grid" data-testid="game-board">
          {#each Array($boardSize) as _, rowIdx (rowIdx)}
            {#each Array($boardSize) as _, colIdx (colIdx)}
              {@const moveInfo = getMoveInfo(rowIdx, colIdx)}
              <BoardCell
                {rowIdx}
                {colIdx}
                visualCellVisitCounts={$visualCellVisitCounts}
                settingsStore={$settingsStore}
                isAvailable={moveInfo.isAvailable}
                isPenalty={moveInfo.isPenalty}
                visualPosition={$visualPosition}
                boardState={$visualBoardState}
                gameState={$gameState}
                on:cellRightClick={(e) => onCellRightClick(e.detail.event, e.detail.row, e.detail.col)}
              />
            {/each}
          {/each}
          
          {#if $settingsStore.showPiece && $visualPosition.row !== null && $visualPosition.col !== null}
            <PlayerPiece
              row={$visualPosition.row}
              col={$visualPosition.col}
              boardSize={$boardSize}
            />
          {/if}
        </div>
      </div>
    {/if}
  {/key}
{/if}

<style>

</style>

==== END OF FILE: src/lib/components/widgets/BoardWrapperWidget.svelte ====


==== START OF FILE: src/lib/components/GameModeModal.svelte ====
<script>
  import { _ } from 'svelte-i18n';
  import { settingsStore } from '$lib/stores/settingsStore.js';
  import { modalStore } from '$lib/stores/modalStore.js';
  import { goto } from '$app/navigation';
  import { base } from '$app/paths';
  import { gameOrchestrator } from '$lib/gameOrchestrator';
  import { get } from 'svelte/store';
  import { gameState } from '$lib/stores/gameState';
  import DontShowAgainCheckbox from './DontShowAgainCheckbox.svelte';
  import { hotkeysAndTooltips } from '$lib/actions/hotkeysAndTooltips.js';

  /**
   * @param {'beginner' | 'experienced' | 'pro'} mode
   */
  function selectMode(mode) {
    const shouldShowFaq = settingsStore.applyGameModePreset(mode);
    gotoAfterFaq();

    function gotoAfterFaq() {
      if (shouldShowFaq) {
        setTimeout(() => {
          modalStore.showModal({
            titleKey: 'faq.title',
            dataTestId: 'faq-modal',
            content: { isFaq: true },
            buttons: [
              { textKey: 'rulesPage.title', onClick: () => { goto(`${base}/rules`); modalStore.closeModal(); }, customClass: 'blue-btn' },
              { textKey: 'modal.ok', primary: true, isHot: true, onClick: () => { modalStore.closeModal(); goto(`${base}/game/vs-computer`); } }
            ]
          });
        }, 100);
      } else {
        goto(`${base}/game/vs-computer`);
      }
    }
  }

  let dontShowAgain = false;
  $: dontShowAgain = !$settingsStore.showGameModeModal;

  /** @param {Event} event */
  function handleCheckboxChange(event) {
    const input = /** @type {HTMLInputElement|null} */ (event.currentTarget);
    if (input && typeof input.checked === 'boolean') {
      settingsStore.updateSettings({ showGameModeModal: !input.checked });
    }
  }
</script>

<div class="game-mode-buttons" use:hotkeysAndTooltips>
  <button class="modal-btn-generic green-btn" on:click={() => selectMode('beginner')} data-testid="beginner-mode-btn">
    {$_('gameModes.beginner')}
  </button>
  <button class="modal-btn-generic blue-btn" on:click={() => selectMode('experienced')} data-testid="experienced-mode-btn">
    {$_('gameModes.experienced')}
  </button>
  <button class="modal-btn-generic danger-btn" on:click={() => selectMode('pro')} data-testid="pro-mode-btn">
    {$_('gameModes.pro')}
  </button>
</div>
<DontShowAgainCheckbox dataTestId="game-mode-modal-dont-show-again-switch" />

<style>
  .game-mode-buttons {
    display: flex;
    flex-direction: column;
    gap: 16px;
    padding-top: 16px;
  }
</style> 

==== END OF FILE: src/lib/components/GameModeModal.svelte ====


==== START OF FILE: docs/elements/checkbox-auto-hide-board.md ====
# Елемент: Чекбокс "Автоматично приховувати дошку"

## Призначення (Purpose)

Активує режим, в якому ігрова дошка автоматично приховується після ходу гравця, стимулюючи гру по пам'яті.

## Джерело Правда (SSoT) та Залежності від Стану (State Dependencies)

-   **`settingsStore.autoHideBoard`**: Основне джерело стану.

## Поведінка (Behavior)

-   Сам чекбокс лише встановлює прапорець `autoHideBoard` у `settingsStore`.
-   **Побічний ефект** цієї дії обробляється в іншому місці (наприклад, у `BoardWrapperWidget.svelte` або централізованому `uiEffectsStore`).
-   Слухач (`subscriber`) в `BoardWrapperWidget` відстежує зміни в `gameState.playerRow`/`playerCol`. Якщо позиція змінилася (тобто гравець зробив хід) і `$settingsStore.autoHideBoard` є `true`, він викликає `settingsStore.toggleShowBoard(false)` з невеликою затримкою.

## Взаємодія з Користувачем (User Interaction)

-   **Клік**: Викликає `settingsStore.toggleAutoHideBoard()`.

## Архітектурні Нотатки та UI/UX

-   **Відмінний приклад SoC**: Компонент чекбокса не містить складної логіки з таймерами чи підписками на стан гри. Він лише змінює налаштування. Окремий, більш високорівневий компонент (`BoardWrapperWidget`) відповідає за реалізацію *ефекту* цього налаштування. Це робить обидва компоненти простішими та більш сфокусованими.
-   Затримка перед приховуванням важлива для UX, щоб гравець встиг побачити результат свого ходу перед тим, як дошка зникне.

## Критерії Прийняття (Acceptance Criteria)

-   [ ] Коли чекбокс увімкнений, після ходу гравця дошка автоматично приховується.
-   [ ] Коли чекбокс вимкнений, дошка залишається видимою після ходу гравця.
-   [ ] При старті нової гри дошка завжди видима, незалежно від цього налаштування.

==== END OF FILE: docs/elements/checkbox-auto-hide-board.md ====


==== FILE NOT FOUND: src/lib/stores/gameState.js ====


