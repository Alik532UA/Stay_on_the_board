
--- START OF FILE src/lib/services/gameEventBus.ts ---
/**
 * @file A simple event bus for decoupling game logic from side effects.
 * Services can dispatch events, and handlers can subscribe to them to perform actions.
 * 
 * @description Цей модуль також підтримує систему нагород через спеціалізовані події.
 */

/**
 * Типи подій для системи нагород.
 */
export interface RewardEventPayloads {
  /** Хід успішно завершено */
  MOVE_COMPLETED: {
    playerId: number;
    playerName: string;
    direction: string;
    distance: number;
    newScore: number;
    jumpedBlockedCells: number;
    totalMoves: number;
  };

  /** Гра завершена */
  GAME_FINISHED: {
    gameMode: string;
    finalScore: number;
    totalMoves: number;
    playerId: number;
    playerName: string;
    isWinner: boolean;
    reason: string;
  };

  /** Досягнуто milestone рахунку */
  SCORE_MILESTONE_REACHED: {
    playerId: number;
    milestone: number;
    currentScore: number;
  };

  /** Серія стрибків через заблоковані клітинки */
  JUMP_STREAK_ACHIEVED: {
    playerId: number;
    streakCount: number;
  };

  /** Виграш раунду в локальній грі */
  ROUND_WON: {
    playerId: number;
    roundNumber: number;
    roundScore: number;
  };

  /** Немає ходів - успішно заявлено */
  NO_MOVES_CLAIMED: {
    playerId: number;
    wasCorrect: boolean;
    bonusAwarded: number;
  };
}

/**
 * Всі типи подій гри.
 */
export type GameEventType =
  | keyof RewardEventPayloads
  | 'CloseModal'
  | 'OpenModal'
  | 'GameStateChanged'
  | 'PlayerTurnStarted'
  | 'PlayerTurnEnded'
  | string; // Для зворотної сумісності

type GameEventPayload = any;
type GameEventListener<T = any> = (payload: T) => void;

class GameEventBus {
  private listeners: Map<GameEventType, GameEventListener[]> = new Map();

  /**
   * Subscribes a listener to a specific event type.
   * @param eventType The type of event to listen for.
   * @param listener The callback function to execute when the event is dispatched.
   * @returns An unsubscribe function.
   */
  subscribe<K extends keyof RewardEventPayloads>(
    eventType: K,
    listener: GameEventListener<RewardEventPayloads[K]>
  ): () => void;
  subscribe(eventType: GameEventType, listener: GameEventListener): () => void;
  subscribe(eventType: GameEventType, listener: GameEventListener): () => void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(listener);

    return () => {
      const eventListeners = this.listeners.get(eventType);
      if (eventListeners) {
        const index = eventListeners.indexOf(listener);
        if (index > -1) {
          eventListeners.splice(index, 1);
        }
      }
    };
  }

  /**
   * Dispatches an event to all subscribed listeners.
   * @param eventType The type of event to dispatch.
   * @param payload The data to pass to the listeners.
   */
  dispatch<K extends keyof RewardEventPayloads>(
    eventType: K,
    payload: RewardEventPayloads[K]
  ): void;
  dispatch(eventType: GameEventType, payload?: GameEventPayload): void;
  dispatch(eventType: GameEventType, payload?: GameEventPayload): void {
    if (this.listeners.has(eventType)) {
      this.listeners.get(eventType)!.forEach(listener => listener(payload));
    }
  }

  /**
   * Видаляє всіх слухачів для певного типу події.
   * Корисно для очищення при демонтажі компонентів.
   */
  clearListeners(eventType?: GameEventType): void {
    if (eventType) {
      this.listeners.delete(eventType);
    } else {
      this.listeners.clear();
    }
  }
}

export const gameEventBus = new GameEventBus();
--- END OF FILE src/lib/services/gameEventBus.ts ---

--- START OF FILE src/lib/services/commandService.ts ---
import { gameEventBus } from './gameEventBus';
import { sideEffectService } from './sideEffectService';
import { logService } from './logService';
import { userActionService } from './userActionService';
import type { GameOverPayload } from '$lib/stores/gameOverStore';
import type { ModalState } from '$lib/stores/modalStore';

/**
 * Тип payload для показу модального вікна — відповідає очікуванням modalStore.showModal
 */
type ShowModalPayload = Partial<ModalState> & { dataTestId: string };

/**
 * Payload для озвучення ходу
 */
interface SpeakMovePayload {
  move: {
    direction: string;
    distance: number;
  };
  lang?: string;
  voiceURI?: string;
  onEndCallback?: () => void;
}

/**
 * Payload для підтвердження зміни розміру дошки
 */
interface BoardResizePayload {
  newSize: number;
}

class CommandService {
  constructor() {
    this.subscribeToEvents();
  }

  private subscribeToEvents() {
    gameEventBus.subscribe('GameOver', (payload) => this.handleGameOver(payload as GameOverPayload));
    gameEventBus.subscribe('CloseModal', () => this.handleCloseModal());
    gameEventBus.subscribe('ShowModal', (payload) => this.handleShowModal(payload as ShowModalPayload));
    gameEventBus.subscribe('SpeakMove', (payload) => this.handleSpeakMove(payload as SpeakMovePayload));
    gameEventBus.subscribe('ReplayGame', () => this.handleReplayGame());
    gameEventBus.subscribe('RequestReplay', () => this.handleRequestReplay());
    gameEventBus.subscribe('BoardResizeConfirmed', (payload) => this.handleBoardResizeConfirmed(payload as BoardResizePayload));
  }

  private handleGameOver(payload: GameOverPayload) {
    logService.logicMove('CommandService: Handling GameOver event', payload);
    sideEffectService.execute({
      type: 'ui/showGameOverModal',
      payload: payload
    });
  }

  private handleCloseModal() {
    logService.logicMove('CommandService: Handling CloseModal event');
    sideEffectService.execute({
      type: 'ui/closeModal'
    });
  }

  private handleShowModal(payload: ShowModalPayload) {
    logService.logicMove('CommandService: Handling ShowModal event', payload);
    sideEffectService.execute({
      type: 'ui/showModal',
      payload: payload
    });
  }

  private handleSpeakMove(payload: SpeakMovePayload) {
    logService.logicMove('CommandService: Handling SpeakMove event', payload);
    sideEffectService.execute({
      type: 'speak_move',
      payload: {
        move: payload.move as { direction: import('$lib/models/Piece').MoveDirectionType; distance: number },
        lang: payload.lang || 'uk',
        voiceURI: payload.voiceURI || null,
        onEndCallback: payload.onEndCallback
      }
    });
  }

  private handleReplayGame() {
    logService.logicMove('CommandService: Handling ReplayGame event');
    userActionService.requestRestart();
  }

  private handleRequestReplay() {
    logService.logicMove('CommandService: Handling RequestReplay event');
    userActionService.requestReplay();
  }

  private handleBoardResizeConfirmed(payload: BoardResizePayload) {
    logService.logicMove('CommandService: Handling BoardResizeConfirmed event', payload);
    userActionService.requestRestartWithSize(payload.newSize);
  }
}

// Initialize the service to start listening for events.
export const commandService = new CommandService();
--- END OF FILE src/lib/services/commandService.ts ---

--- START OF FILE src/lib/services/noMovesService.ts ---
// src/lib/services/noMovesService.ts
import { logService } from './logService';
import { get } from 'svelte/store';
import { gameEventBus } from './gameEventBus';
import { calculateFinalScore } from './scoreService';
import { endGameService } from './endGameService';
import { availableMovesService } from './availableMovesService';
import { gameStore } from '$lib/stores/gameStore';
import { boardStore } from '$lib/stores/boardStore';
import { playerStore } from '$lib/stores/playerStore';
import { scoreStore } from '$lib/stores/scoreStore';
import { uiStateStore } from '$lib/stores/uiStateStore';

export const noMovesService = {
  async claimNoMoves(): Promise<void> {
    const playerState = get(playerStore);
    if (!playerState) return;

    const availableMoves = availableMovesService.getAvailableMoves();

    if (availableMoves.length > 0) {
      const currentPlayerName = playerState.players[playerState.currentPlayerIndex].name;
      await endGameService.endGame('modal.gameOverReasonPlayerLied', { playerName: currentPlayerName });
    } else {
      this.dispatchNoMovesEvent('human');
    }
  },

  dispatchNoMovesEvent(playerType: 'human' | 'computer') {
    logService.GAME_MODE('[noMovesService] dispatchNoMovesEvent called', { playerType });
    const boardState = get(boardStore);
    const playerState = get(playerStore);
    const scoreState = get(scoreStore);
    const uiState = get(uiStateStore);
    if (!boardState || !playerState || !scoreState || !uiState) return;

    const scoreDetails = calculateFinalScore(boardState, playerState, scoreState, uiState, 'training');
    gameEventBus.dispatch('ShowNoMovesModal', {
      playerType,
      scoreDetails,
      boardSize: boardState.boardSize
    });
    const gameMode = get(gameStore).mode;
    if (gameMode) {
      gameMode.pauseTimers();
    }
  }
};
--- END OF FILE src/lib/services/noMovesService.ts ---

--- START OF FILE src/lib/services/endGameService.ts ---
// src/lib/services/endGameService.ts
import { get } from 'svelte/store';
import { gameOverStore } from '$lib/stores/gameOverStore';
import { calculateFinalScore, determineWinner } from './scoreService';
import { gameEventBus } from './gameEventBus';
import { logService } from './logService';
import { timeService } from './timeService';
import { boardStore } from '$lib/stores/boardStore';
import { playerStore } from '$lib/stores/playerStore';
import { scoreStore, initialScoreState } from '$lib/stores/scoreStore';
import { uiStateStore } from '$lib/stores/uiStateStore';
import type { Player } from '$lib/models/player';
import { tick } from 'svelte';
import { gameModeService } from './gameModeService';

export const endGameService = {
  async endGame(reasonKey: string, reasonValues: Record<string, any> | null = null): Promise<void> {
    logService.GAME_MODE(`[endGameService] endGame called with reason: '${reasonKey}'`);

    // 1. Оновлюємо ключовий стан, від якого залежить розрахунок
    uiStateStore.update(s => s ? ({ ...s, isGameOver: true, gameOverReasonKey: reasonKey, gameOverReasonValues: reasonValues }) : null);
    timeService.stopGameTimer();
    timeService.stopTurnTimer();

    // 2. Чекаємо, доки Svelte оновить стан
    await tick();
    logService.score('[endGameService] Svelte tick completed after setting gameOver state.');

    // 3. Отримуємо АКТУАЛЬНИЙ стан після оновлення
    const boardState = get(boardStore);
    const playerState = get(playerStore);
    const scoreState = get(scoreStore);
    const uiState = get(uiStateStore);

    if (!boardState || !playerState || !scoreState || !uiState) {
      logService.score('[endGameService] Aborted: one or more stores are not available.');
      return;
    }

    const currentGameMode = gameModeService.getCurrentMode();
    const gameType = currentGameMode ? currentGameMode.getModeName() : 'training';

    // 4. Розраховуємо фінальний рахунок на основі АКТУАЛЬНОГО стану
    logService.score('[endGameService] Calculating final score with states:', {
      playerScore: playerState.players.find(p => p.type === 'human')?.score,
      noMovesBonus: scoreState.noMovesBonus,
      finishBonus: uiState.gameOverReasonKey === 'modal.gameOverReasonBonus' ? boardState.boardSize : 0,
      reasonKey: uiState.gameOverReasonKey
    });
    const finalScoreDetails = calculateFinalScore(boardState, playerState, scoreState, uiState, gameType);
    logService.score('[endGameService] Final score calculated:', finalScoreDetails);

    // 5. Оновлюємо залежні стори
    // ВАЖЛИВО: Для локальної та онлайн гри ми НЕ перезаписуємо рахунок гравців глобальною сумою.
    // У цих режимах рахунок кожного гравця ведеться окремо в playerStore (див. LocalGameMode.ts).
    if (gameType !== 'local' && gameType !== 'online') {
      const humanPlayer = playerState.players.find(p => p.type === 'human');
      if (humanPlayer) {
        const updatedPlayers = playerState.players.map(p =>
          p.id === humanPlayer.id ? { ...p, score: finalScoreDetails.totalScore } : p
        );
        playerStore.set({ ...playerState, players: updatedPlayers });
        logService.score(`[endGameService] playerStore updated. New score: ${finalScoreDetails.totalScore}`);
      }
    }

    scoreStore.set(initialScoreState);
    logService.score('[endGameService] scoreStore has been reset.');

    // 6. Визначаємо переможця і показуємо модальне вікно
    const finalPlayerState = get(playerStore)!;
    const { winners, loser } = determineWinner(finalPlayerState, reasonKey, playerState.currentPlayerIndex);

    let finalReasonKey = reasonKey;
    const finalReasonValues = { ...reasonValues };

    if (gameType === 'local' && loser) {
      if (reasonKey === 'modal.gameOverReasonOut') {
        finalReasonKey = 'modal.gameOverReasonPlayerOut';
      } else if (reasonKey === 'modal.gameOverReasonBlocked') {
        finalReasonKey = 'modal.gameOverReasonPlayerBlocked';
      }

      if (finalReasonKey !== reasonKey) {
        finalReasonValues.playerName = loser.name;
      }
    }

    const gameOverPayload = {
      scores: finalPlayerState.players.map((p: Player) => ({ playerId: p.id, score: p.score, name: p.name, color: p.color })),
      winners: winners,
      loser: loser,
      reasonKey: finalReasonKey,
      reasonValues: finalReasonValues,
      finalScoreDetails,
      gameType: gameType,
    };

    logService.score('[endGameService] Dispatching GameOver event with payload:', gameOverPayload);
    gameOverStore.setGameOver(gameOverPayload);
    gameEventBus.dispatch('GameOver', { ...gameOverPayload, state: { ...boardState, ...finalPlayerState, ...get(scoreStore)!, ...uiState } });
  }
};
--- END OF FILE src/lib/services/endGameService.ts ---

--- START OF FILE src/lib/components/ModalManager.svelte ---
<script lang="ts">
	import { onMount } from "svelte";
	import { gameEventBus } from "$lib/services/gameEventBus";
	import { userActionService } from "$lib/services/userActionService";
	import { get } from "svelte/store";
	import { modalStore } from "$lib/stores/modalStore";
	import { _, locale } from "svelte-i18n";
	import { gameSettingsStore } from "$lib/stores/gameSettingsStore";
	import { speakText } from "$lib/services/speechService";

	onMount(() => {
		const unsubscribe = gameEventBus.subscribe(
			"ShowNoMovesModal",
			(payload) => {
				const { playerType, scoreDetails, boardSize } = payload;
				const titleKey =
					playerType === "human"
						? "modal.playerNoMovesTitle"
						: "modal.computerNoMovesTitle";
				const contentKey =
					playerType === "human"
						? "modal.playerNoMovesContent"
						: "modal.computerNoMovesContent";

				if (get(gameSettingsStore).speakModalTitles) {
					const title = get(_)(titleKey);
					const lang = get(locale) || "uk";
					const voiceURI = get(gameSettingsStore).selectedVoiceURI;
					speakText(title, lang, voiceURI, undefined);
				}

				modalStore.showModal({
					titleKey,
					content: {
						reason: get(_)(contentKey),
						scoreDetails: scoreDetails,
					},
					buttons: [
						{
							textKey: "modal.continueGame",
							customClass: "green-btn",
							isHot: true,
							onClick: () =>
								userActionService.handleModalAction(
									"continueAfterNoMoves",
								),
							dataTestId: "continue-game-no-moves-btn",
						},
						{
							text: get(_)("modal.finishGameWithBonus", {
								values: { bonus: boardSize },
							}),
							onClick: () =>
								userActionService.handleModalAction(
									"finishWithBonus",
									{ reasonKey: "modal.gameOverReasonBonus" },
								),
							dataTestId: "finish-game-with-bonus-btn",
						},
						{
							textKey: "modal.watchReplay",
							customClass: "blue-btn",
							onClick: () =>
								userActionService.handleModalAction(
									"requestReplay",
								),
							dataTestId: `watch-replay-${playerType}-no-moves-btn`,
						},
					],
					closable: false,
					dataTestId:
						playerType === "human"
							? "player-no-moves-modal"
							: "opponent-trapped-modal",
				});
			},
		);

		return () => {
			unsubscribe();
		};
	});
</script>
--- END OF FILE src/lib/components/ModalManager.svelte ---

--- START OF FILE src/lib/stores/gameOverStore.ts ---
import { writable } from 'svelte/store';
import type { Player } from '$lib/models/player';

/**
 * Деталі фінального рахунку
 */
export interface FinalScoreDetails {
  baseScore: number;
  totalPenalty: number;
  sizeBonus?: number;
  blockModeBonus?: number;
  jumpBonus?: number;
  noMovesBonus?: number;
  finishBonus?: number;
  distanceBonus?: number;
  totalScore: number;
}

/**
 * Результат гравця (для відображення в модальному вікні)
 */
export interface PlayerScoreResult {
  playerId: number;
  score: number;
  name: string;
  color: string;
}

/**
 * Результат гри (payload для setGameOver)
 */
export interface GameOverPayload {
  scores: PlayerScoreResult[];
  winners: Player[];
  loser: Player | null;
  reasonKey: string;
  reasonValues: Record<string, string | number> | null;
  finalScoreDetails: FinalScoreDetails;
  gameType: 'training' | 'local' | 'timed' | 'online' | 'virtual-player';
}

/**
 * Стан gameOverStore
 */
export interface GameOverStoreState {
  isGameOver: boolean;
  gameResult: GameOverPayload | null;
}

/**
 * Глобальний стор для збереження стану завершення гри
 * Цей стор забезпечує персистентність даних при переходах між сторінками
 */
const createGameOverStore = () => {
  const { subscribe, set, update } = writable<GameOverStoreState>({
    isGameOver: false,
    gameResult: null,
  });

  return {
    subscribe,
    setGameOver: (result: GameOverPayload) => {
      update(state => ({
        ...state,
        isGameOver: true,
        gameResult: result,
      }));
    },
    resetGameOverState: () => {
      update(state => ({
        ...state,
        isGameOver: false,
        gameResult: null,
      }));
    },
    clearGameOverState: () => {
      update(state => ({
        ...state,
        isGameOver: false,
        gameResult: null,
      }));
    },
    // НОВИЙ МЕТОД для відновлення стану
    restoreState: (newState: GameOverStoreState) => {
      set(newState);
    }
  };
};

export const gameOverStore = createGameOverStore();

--- END OF FILE src/lib/stores/gameOverStore.ts ---

--- START OF FILE src/lib/stores/modalStore.ts ---
// src/lib/stores/modalStore.ts
/**
 * @file Store для керування модальними вікнами.
 * @description Підтримує стек модальних вікон для правильного закриття.
 */

import { writable } from 'svelte/store';
import { logService } from '$lib/services/logService';

/**
 * Кнопка модального вікна.
 */
export interface ModalButton {
    text?: string;
    textKey?: string;
    primary?: boolean;
    onClick?: () => void;
    disabled?: boolean;
    customClass?: string;
    isHot?: boolean;
    hotKey?: string;
    dataTestId?: string;
}

/**
 * Контент модального вікна.
 */
export interface ModalContent {
    reason?: string;
    score?: number;
    reasonKey?: string;
    scoreDetails?: unknown;
    isFaq?: boolean;
}

/**
 * Стан модального вікна.
 */
export interface ModalState {
    isOpen: boolean;
    title?: string;
    titleKey?: string;
    content?: string | ModalContent | unknown;
    contentKey?: string;
    buttons: ModalButton[];
    component?: unknown;
    props?: Record<string, unknown>;
    closable?: boolean;
    closeOnOverlayClick?: boolean;
    dataTestId?: string;
    customClass?: string;
    titleValues?: Record<string, unknown>;
}

const initialState: ModalState = {
    isOpen: false,
    title: '',
    content: '',
    buttons: [],
    component: null,
    props: {},
    closable: true,
    closeOnOverlayClick: false,
    dataTestId: undefined,
    customClass: undefined
};

const store = writable<ModalState>(initialState);
const { subscribe, set, update } = store;

const modalStack: ModalState[] = [];

export const modalState = { subscribe };

/**
 * Показує модальне вікно.
 */
export function showModal({ dataTestId, ...modalDetails }: Partial<ModalState> & { dataTestId: string }): void {
    update(currentState => {
        // НАВІЩО: Ця перевірка запобігає "нашаруванню" однакових модалок.
        if (currentState.isOpen) {
            const sameIdentity =
                (dataTestId && currentState.dataTestId === dataTestId) ||
                (!dataTestId && modalDetails?.titleKey && currentState.titleKey === modalDetails.titleKey);
            if (!sameIdentity) {
                modalStack.push(currentState);
            } else {
                logService.modal(`[ModalStore] showModal: Prevented stacking identical modal '${dataTestId || modalDetails.titleKey}'.`);
            }
        }
        const newState: ModalState = {
            ...initialState,
            ...modalDetails,
            dataTestId,
            isOpen: true,
        };
        logService.modal(`[ModalStore] showModal called. New modal: '${newState.dataTestId || newState.titleKey}'. Stack size: ${modalStack.length}`, { newState, stack: [...modalStack] });
        return newState;
    });
}

/**
 * Показує модальне вікно, замінюючи поточне (без стеку).
 */
export function showModalAsReplacement(modalDetails: Partial<ModalState>): void {
    logService.modal(`[ModalStore] showModalAsReplacement called. Clearing stack and showing new modal: '${modalDetails.dataTestId || modalDetails.titleKey}'.`, { modalDetails });
    modalStack.length = 0;
    const newState: ModalState = {
        ...initialState,
        ...modalDetails,
        isOpen: true,
    };
    set(newState);
}

/**
 * Закриває поточне модальне вікно.
 */
export function closeModal(): void {
    logService.modal(`[ModalStore] closeModal called. Stack size before action: ${modalStack.length}`, { stack: [...modalStack] });
    if (modalStack.length > 0) {
        const previousState = modalStack.pop();
        if (previousState) {
            logService.modal(`[ModalStore] Popped '${previousState.dataTestId || previousState.titleKey}' from stack. Restoring previous state.`, { previousState });
            set(previousState);
        }
    } else {
        logService.modal('[ModalStore] Stack is empty. Resetting to initial state.', { initialState });
        set({ ...initialState });
    }
}

/**
 * Закриває всі модальні вікна.
 */
export function closeAllModals(): void {
    logService.modal(`[ModalStore] closeAllModals called. Clearing stack of size ${modalStack.length}.`);
    modalStack.length = 0;
    set({ ...initialState });
}

export const modalStore = {
    subscribe,
    closeModal,
    showModal,
    showModalAsReplacement,
    closeAllModals
};
--- END OF FILE src/lib/stores/modalStore.ts ---

