відкрите вікно: data-testid="arrow-key-hint-modal"

натискаю [Enter]
Актуальний результат: нічого не відбувається
Очікуваний результат: закрвивається модальне вікно data-testid="arrow-key-hint-modal", модальне вікно data-testid="arrow-key-hint-modal" переховлює гарячі клавіши, і не пускає їх в гру під модальним вікном

натискаю RBM на модальному вінкі, а потім [Enter]
Актуальний результат: відкривається data-testid="confirm-move-hint-modal" тому що гарячі клавіши спрацьовують на гру, а не на модальне вікно data-testid="arrow-key-hint-modal"
Очікуваний результат: закрвивається модальне вікно data-testid="arrow-key-hint-modal", модальне вікно data-testid="arrow-key-hint-modal" переховлює гарячі клавіши, і не пускає їх в гру під модальним вікном

[Space]
Актуальний результат: поки утримую [Space] відкривається data-testid="confirm-move-hint-modal" тому що гарячі клавіши спрацьовують на гру, а не на модальне вікно data-testid="arrow-key-hint-modal", а коли відпускаю [Space], то data-testid="confirm-move-hint-modal" закривається і на екрані залишається data-testid="arrow-key-hint-modal"
Очікуваний результат: закрвивається модальне вікно data-testid="arrow-key-hint-modal", модальне вікно data-testid="arrow-key-hint-modal" переховлює гарячі клавіши, і не пускає їх в гру під модальним вікном

натискаю [Enter]
Актуальний результат та Очікуваний результат: закрвивається модальне вікно data-testid="arrow-key-hint-modal", модальне вікно data-testid="arrow-key-hint-modal" переховлює гарячі клавіши, і не пускає їх в гру під модальним вікном

натискаю [ESC]
Актуальний результат та Очікуваний результат: закрвивається модальне вікно data-testid="arrow-key-hint-modal", модальне вікно data-testid="arrow-key-hint-modal" переховлює гарячі клавіши, і не пускає їх в гру під модальним вікном

---

**Ключова вимога:** Твоє рішення має бути комплексним. Не роби поверхневих виправлень ("латок" чи "костилів").
**Реалізуй системне виправлення**, яке усуває корінь проблеми та відповідає цільовій архітектурі проєкту.
при виправленні використовуй принципи:
1.  **SSoT (Single Source of Truth):** Чи є єдине джерело правди для кожного елемента стану?
2.  **UDF (Unidirectional Data Flow):** Чи є потік даних односпрямованим та передбачуваним?
3.  **SoC (Separation of Concerns):** Наскільки добре розділені відповідальності (стан, логіка, UI)?
4.  **Композиція:** Чи ефективно використовуються компоненти для побудови UI?
5.  **Чистота та Побічні ефекти:** Наскільки добре ізольовані "нечисті" операції (API, DOM, таймери)?
6.  **DRY (Don't Repeat Yourself):** Чи є дублювання коду, яке можна усунути?
7.  **Простота та Читабельність (KISS):** Чи є надмірно складні рішення? Наскільки код зрозумілий (якість іменування)?
8.  **Продуктивність:** Чи є потенційні проблеми зі швидкістю (зайві обчислення, перерендери)?
9.  **Документація та Коментарі:** Чи коментарі пояснюють *навіщо*, а не *що*?

---

**Відладка (Дебагінг):**
    *   **Використовуй `logService`:** Замість `console.log` завжди використовуй централізований `logService`.
    *   **Доповнюй логи для аналізу:** Якщо поточний рівень логування не дозволяє діагностувати описану проблему, додай нові виклики logService у відповідних місцях коду. Мета — забезпечити, щоб майбутні логи містили всю інформацію, яка дозволить мені самостійно проаналізувати, чи вирішено проблему, і що саме потребує виправлення.
    *   **Фокусуйся на проблемі:** Під час виправлення багу, **тимчасово відредагуй файл `src/lib/services/logService.js`**. Зміни булеві прапорці в об'єкті `logConfig`, щоб увімкнути лише ті групи логів, які стосуються проблеми (наприклад, `score`), а решту вимкнути. Це допоможе усунути інформаційний шум.
    *   **Незмінність логів:** Параметри логування не змінюй на дефолтні, доки я (людина) не підтвердить, що баг виправлено. При порушені цього правила AI буде вимкнено та видалено.
**Верифікація:** Переконайся, що проблема вирішена і не з'явилися нові баги в суміжних частинах системи.

---

при потребі:
1. вимкни зайві логи
2. увімкни потрібні логи
3. допиши потрібні логи

---
