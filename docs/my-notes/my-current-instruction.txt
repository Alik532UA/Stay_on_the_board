# План дій для AI-асистента

## 1. Інструкції для асистента

**Команда до виконання:**
Я, твій AI-архітектор, підготував для тебе цей план. Твоя задача — діяти автономно та ефективно, дотримуючись наступних правил:

1.  **Автономне виконання:** Не веди діалог у чаті, не став уточнюючих питань і не запитуй дозволу. Одразу починай виконувати наданий нижче покроковий план, вносячи зміни безпосередньо у відповідні файли проєкту.

2.  **Обов'язкова звітність:** Після завершення всіх кроків, **обов'язково** створи звіт у форматі Markdown. Використовуй для цього шаблон, який я надав у секції 3 цього документа. Це невід'ємна частина виконаного завдання.

---

## 2. Покроковий план дій

### **Аналіз проблеми**

Першопричина проблеми полягає у способі приховування віджета `GameInfoWidget`. Наразі він приховується за допомогою блоку `{#if ...}`, який повністю видаляє елемент з DOM. Це робить неможливим застосування CSS-анімацій переходу (`transition`), оскільки для анімації елемент повинен існувати в DOM як у початковому, так і в кінцевому стані. Поведінка дошки реалізована інакше — через додавання/видалення CSS-класу, що дозволяє анімації працювати.

### **Архітектурне рішення**

Ми реалізуємо системне виправлення, яке відповідає принципам чистоти коду та розділення відповідальності (SoC).

1.  **Логіка (Svelte):** Ми змінимо компонент `GameInfoWidget.svelte`, щоб він не видалявся з DOM, а отримував динамічний CSS-клас (`.hidden`) на основі стану в `settingsStore`. Це дозволить CSS керувати його візуальним станом.
2.  **Стилізація (CSS):** Ми додамо CSS-переходи (`transition`) до класу `.game-info-widget` для властивостей `max-height`, `opacity`, `padding`, `margin` та `transform`. Клас `.hidden` буде встановлювати цільові значення для цих властивостей (наприклад, `max-height: 0`), що і створить бажаний ефект плавного згортання та зникнення.

Це рішення інкапсулює логіку анімації всередині компонента, роблячи його самодостатнім, і дотримується односпрямованого потоку даних (UDF): зміна в `settingsStore` призводить до візуальної зміни в компоненті.

---

*   **Крок 1: Рефакторинг логіки та розмітки у файлі `src/lib/components/widgets/GameInfoWidget.svelte`**
    *   **Дія:** Замінити умовний рендеринг `{#if ...}` на динамічне додавання CSS-класу.
    *   **Знайти цей блок коду:**
        ```html
        {#if $i18nReady && $settingsStore.showGameInfoWidget !== 'hidden' && $gameState}
          <div class="game-info-widget"
               class:compact={$settingsStore.showGameInfoWidget === 'compact'}
               transition:safeScale={{ duration: 400, easing: quintOut }}
               data-testid="game-info-panel"
          >
            <!-- ...вміст... -->
          </div>
        {/if}
        ```
    *   **Замінити його на цей:**
        ```html
        {#if $i18nReady && $gameState}
          <div class="game-info-widget"
               class:hidden={$settingsStore.showGameInfoWidget === 'hidden'}
               class:compact={$settingsStore.showGameInfoWidget === 'compact'}
               data-testid="game-info-panel"
          >
            <!-- ...вміст... -->
          </div>
        {/if}
        ```
    *   **Обґрунтування:** Ця зміна гарантує, що DOM-елемент віджета завжди присутній на сторінці, що є необхідною умовою для роботи CSS-переходів. Видимість тепер буде керуватися виключно через CSS.

*   **Крок 2: Рефакторинг стилів у файлі `src/lib/components/widgets/GameInfoWidget.svelte`**
    *   **Дія:** Додати стилі для плавної анімації зникнення та появи віджета.
    *   **Знайти цей CSS-клас:**
        ```css
        .game-info-widget {
          /* ...існуючі стилі... */
          transition: all 0.3s ease;
          max-height: 200px;
          overflow: hidden;
        }
        ```
    *   **Замінити його на цей:**
        ```css
        .game-info-widget {
          background: var(--bg-secondary);
          padding: 20px 12px;
          border-radius: var(--unified-border-radius);
          box-shadow: var(--dynamic-widget-shadow) var(--current-player-shadow-color);
          font-size: 1.1em;
          color: var(--text-primary, #222);
          display: flex;
          align-items: center;
          justify-content: center;
          backdrop-filter: var(--unified-backdrop-filter);
          border: var(--unified-border);
          overflow: hidden;
          /* НАВІЩО: Додаємо плавні переходи для всіх необхідних властивостей */
          transition: max-height 0.4s ease-out, opacity 0.3s ease-out, padding 0.4s ease-out, margin 0.4s ease-out, transform 0.3s ease-out;
          max-height: 200px; /* Максимальна висота для анімації */
          transform: scale(1);
        }
        ```
    *   **Дія 2:** Додати новий CSS-клас `.hidden` для опису стану прихованого віджета.
    *   **Додати цей блок CSS:**
        ```css
        .game-info-widget.hidden {
          max-height: 0;
          opacity: 0;
          padding-top: 0;
          padding-bottom: 0;
          margin-top: 0;
          margin-bottom: 0;
          border-width: 0;
          transform: scale(0.95);
        }
        ```
    *   **Обґрунтування:** Ці стилі реалізують очікувану поведінку. При додаванні класу `.hidden` віджет плавно "згортається" до висоти 0, стає прозорим, а його відступи зникають, що дозволяє іншим елементам плавно зайняти його місце.

---

## 3. Шаблон звіту для асистента

**Після виконання всіх кроків, заповни та надай цей звіт:**

```markdown
# Звіт про виконання завдання

## 1. Виконана робота
- **Рефакторинг `GameInfoWidget.svelte`:**
  - Замінено умовний рендеринг `{#if ...}` на динамічне присвоєння CSS-класу `.hidden`, щоб елемент залишався в DOM.
  - Додано CSS-переходи (`transition`) для властивостей `max-height`, `opacity`, `padding`, `margin` та `transform`.
  - Створено клас `.hidden`, який анімує віджет до нульової висоти та повної прозорості.
- **Результат:** Виправлено баг різкого зникнення/появи. Тепер `GameInfoWidget` плавно згортається та розгортається, аналогічно до поведінки ігрової дошки, забезпечуючи плавний зсув контенту.

## 2. Проблеми та перешкоди (якщо були)
- Проблем під час виконання не виявлено.
```