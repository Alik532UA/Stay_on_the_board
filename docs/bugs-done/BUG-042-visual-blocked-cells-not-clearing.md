# BUG-042: Заблоковані клітинки не зникають після натискання "Продовжити"

## Опис проблеми

**Дата виявлення:** 2025-01-27  
**Статус:** ✅ Виправлено  
**Пріоритет:** Високий  

### Симптоми
- Після натискання кнопки "Продовжити" після успішної заявки "Немає ходів"
- Заблоковані клітинки залишаються видимими на дошці
- Візуальний стан не синхронізується з логічним станом

### Очікувана поведінка
- Заблоковані клітинки повинні зникати з дошки
- Дошка повинна показуватися як чиста (без заблокованих клітинок)
- Візуальний стан повинен повністю синхронізуватися з логічним станом

## Аналіз причини

### Корінь проблеми
Проблема полягала в тому, що хоча ми очищували `cellVisitCounts` в `gameState`, наш `derived` стор `visualCellVisitCounts` продовжував брати застарілі дані зі "знімків" стану, що зберігаються в `moveHistory`.

### Технічні деталі
1. **Логічний стан:** `cellVisitCounts` очищувався правильно
2. **Візуальний стан:** `visualCellVisitCounts` використовував `moveHistory` для отримання даних
3. **Проблема:** `moveHistory` містила застарілі записи з попередніми станами `visits`

### Архітектурний контекст
- **SSoT:** `gameState` є єдиним джерелом істини
- **UDF:** Дані течуть від `gameState` до `derivedState` до UI
- **SoC:** Візуалізація відокремлена від логіки, але залежить від правильних даних

## Рішення

### Стратегія
Найбільш надійний спосіб виправити проблему — при натисканні "Продовжити" не тільки скидати лічильники, але й очищувати саму історію ходів, залишаючи в ній лише один запис про поточну позицію фігури з порожнім списком відвіданих клітинок.

### Реалізація

#### Крок 1: Оновлення логіки в `gameOrchestrator.ts`

**Файл:** `src/lib/gameOrchestrator.ts`  
**Функція:** `continueAfterNoMoves()`

```typescript
const continueChanges = {
  score: state.score + bonus,
  noMovesBonus: state.noMovesBonus + bonus,
  cellVisitCounts: {}, // Очищення дошки
  // Скидаємо історію, щоб візуалізація почалася з чистого аркуша
  moveHistory: [{ 
    pos: { row: state.playerRow, col: state.playerCol }, 
    blocked: [], 
    visits: {} 
  }],
  availableMoves: getAvailableMoves(
    state.playerRow,
    state.playerCol,
    state.boardSize,
    {},
    settings.blockOnVisitCount,
    state.board
  ),
  noMovesClaimed: false,
  isComputerMoveInProgress: false
};
```

### Ключові зміни
- ✅ Додано скидання `moveHistory` до одного запису
- ✅ Запис містить поточну позицію з порожнім `visits: {}`
- ✅ Це гарантує, що `visualCellVisitCounts` поверне порожній об'єкт

## Тестування

### Сценарій тесту
1. Запустити гру
2. Зробити кілька ходів, щоб заблокувати клітинки
3. Натиснути "Немає ходів" та "Продовжити"
4. Перевірити, що заблоковані клітинки зникли з дошки

### Очікувані результати
- ✅ Заблоковані клітинки зникають з дошки
- ✅ Візуальний стан синхронізується з логічним
- ✅ Дошка показується як чиста
- ✅ Немає побічних ефектів на інші функції

## Вплив на архітектуру

### Принципи, що дотримуються
- ✅ **SSoT:** `gameState` залишається єдиним джерелом істини
- ✅ **UDF:** Потік даних залишається унідирекціональним
- ✅ **SoC:** Візуалізація залишається відокремленою від логіки

### Переваги рішення
1. **Надійність:** Гарантує повну синхронізацію візуального та логічного стану
2. **Простота:** Мінімальні зміни в існуючому коді
3. **Безпека:** Не впливає на інші функції гри

## Файли, що змінилися

- `src/lib/gameOrchestrator.ts` - оновлено функцію `continueAfterNoMoves()`

## Пов'язані баги
- Немає

## Коментарі
Це виправлення демонструє важливість правильного управління `moveHistory` для синхронізації візуального та логічного стану. Рішення є елегантним та відповідає принципам архітектури проекту. 