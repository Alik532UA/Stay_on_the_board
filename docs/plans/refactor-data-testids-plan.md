# План рефакторингу та уніфікації `data-testid`

**Версія:** 2.0
**Статус:** Проектування

**Мета:** Створити надійну, масштабовану та передбачувану систему `data-testid` для всього додатку. Цей рефакторинг забезпечить стабільність E2E-тестів, спростить їх підтримку та гарантує повне покриття інтерактивних та інформаційних елементів, що перевіряються.

## 1. Архітектурні принципи та конвенція іменування

### 1.1. Принципи

-   **SSoT (Single Source of Truth):** Базовий `data-testid` для компонента або сторінки визначається в одному місці. Дочірні елементи будують свої ID на його основі.
-   **SoC (Separation of Concerns):** Логіка генерації ID інкапсульована в межах компонентів. Тести не повинні знати про внутрішню структуру компонентів.
-   **DRY (Don't Repeat Yourself):** Уніфікована конвенція іменування запобігає дублюванню та розбіжностям.
-   **KISS (Keep It Simple, Stupid):** Структура ID є простою, логічною та легкою для розуміння як людиною, так і автоматизованими системами.

### 1.2. Глобальна конвенція іменування

Всі `data-testid` будуть слідувати шаблону: **`[scope]-[component]-[element]-[identifier]`**

-   **`scope`:** (Опціонально) Сторінка або великий функціональний блок (`main-menu`, `game`, `local-setup`).
-   **`component`:** Назва компонента (`modal`, `board`, `player-manager`).
-   **`element`:** Тип або призначення елемента (`title`, `confirm-btn`, `name-input`).
-   **`identifier`:** (Опціонально) Унікальний ідентифікатор для динамічних елементів (індекс, назва, унікальний ключ).

**Приклади:**
-   `main-menu-vs-computer-btn`
-   `game-modal-game-over-title`
-   `local-setup-player-manager-player-input-1`

## 2. Аналіз покриття на основі існуючих тестів

Я проаналізував надані файли тестів (`*.spec.ts`) і виявив ключові `data-testid`, які вже використовуються і повинні бути збережені або адаптовані до нової конвенції.

**Ключові компоненти та модальні вікна, що тестуються:**
-   `main-menu`
-   `game-board`
-   `direction-controls-panel`
-   `modal` (різні типи: `game-mode`, `faq`, `board-resize-confirm`, `game-over`, `opponent-trapped`, `player-no-moves`, `replay`)
-   `settings` (включаючи `block-mode-toggle`, `increase-board-size-btn`)
-   `test-mode-widget`

## 3. План реалізації

### Крок 1: Рефакторинг `modalStore` та `Modal.svelte` (SSoT, UDF)

Це ядро проблеми. Ми повинні централізувати логіку `data-testid` для модальних вікон.

1.  **`modalStore.js`:**
    -   Модифікувати функцію `showModal`, щоб вона обов'язково приймала `dataTestId` як основний ідентифікатор модального вікна. Це буде нашим **SSoT**.
2.  **`Modal.svelte`:**
    -   Прибрати складну логіку генерації `data-testid` з компонента.
    -   Компонент повинен отримувати базовий `dataTestId` з `$modalState`.
    -   Внутрішні елементи (заголовок, кнопки, контент) повинні будувати свої `data-testid` на основі базового, додаючи суфікси (`-title`, `-confirm-btn` і т.д.). Це забезпечить **SoC** та **UDF**.

### Крок 2: Ревізія та рефакторинг всіх викликів `showModal`

Пройтися по всьому проєкту, знайти всі місця, де викликаються модальні вікна, і передати в них `dataTestId` згідно з новою конвенцією.

**Приклад:**
```javascript
// Було (або було відсутнє):
modalStore.showModal({ titleKey: 'modal.gameOverTitle' });

// Стане:
modalStore.showModal({
  titleKey: 'modal.gameOverTitle',
  dataTestId: 'game-over-modal'
});
```

### Крок 3: Уніфікація `data-testid` на сторінках та в компонентах

Систематично пройти по компонентах, визначених у кроці 2, і застосувати нову конвенцію.

-   **`MainMenu.svelte`:**
    -   `main-menu-vs-computer-btn`
    -   `main-menu-local-game-btn`
    -   ...
-   **`ControlsPanelWidget.svelte` (ігрові контролери):**
    -   `game-controls-confirm-move-btn`
    -   `game-controls-no-moves-btn`
    -   `game-controls-cash-out-btn`
-   **`SettingsExpanderWidget.svelte` (налаштування гри):**
    -   `game-settings-board-size-increase-btn`
    -   `game-settings-board-size-decrease-btn`
    -   `game-settings-block-mode-toggle`
-   **`LocalGameSettings.svelte`:**
    -   `local-setup-player-manager-add-player-btn`
    -   `local-setup-player-manager-player-input-0`
    -   `local-setup-start-game-btn`

### Крок 4: Оновлення автотестів

Після завершення рефакторингу кодової бази, необхідно оновити всі селектори `getByTestId()` у файлах `*.spec.ts`, щоб вони відповідали новій конвенції. Це гарантує, що тести залишаться робочими та надійними.

### Крок 5: Аудит та повне покриття інтерактивних елементів

Після основного рефакторингу виявилося, що деякі інтерактивні елементи, як-от кнопки в `SettingsExpanderWidget`, залишилися без `data-testid`. Цей крок спрямований на усунення таких прогалин.

1.  **Провести аудит компонентів:** Систематично перевірити всі інтерактивні компоненти (`<button>`, `<a>`, `<input>`, тощо) у проекті на наявність `data-testid`.
2.  **Ідентифікувати відсутні ID:** Скласти список елементів, у яких відсутній `data-testid`.
3.  **Додати унікальні `data-testid`:** Для кожного знайденого елемента створити унікальний `data-testid` відповідно до конвенції іменування: `[scope]-[component]-[element]-[identifier]`.
4.  **Пріоритет:** Особливу увагу приділити компонентам, що містять важливу для користувача логіку, але не були покриті початковим планом.

## 4. Очікувані результати

-   **Усунення дублювання:** `data-testid` більше не будуть повторюватися.
-   **Передбачуваність:** Структура ID буде логічною та послідовною у всьому додатку.
-   **Повне покриття:** Всі інтерактивні елементи, що перевіряються тестами, будуть мати унікальні ідентифікатори.
-   **Спрощення підтримки:** Додавання нових тестів та підтримка існуючих стане значно простішою.
-   **Відповідність сучасним практикам:** Система буде відповідати найкращим практикам розробки та тестування.