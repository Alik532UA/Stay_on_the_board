# Архітектурний План Покращення v12

Цей документ аналізує поточну архітектуру кодової бази та пропонує план дій для її покращення з метою підготовки до масштабування та додавання нових ігрових режимів, зокрема "Гра онлайн".

## Частина 1: Комплексний аудит коду

Нижче наведено оцінку поточної архітектури за ключовими критеріями.

### Архітектура та Структура

- [ ] **SSoT (Single Source of Truth):** `85/100`
  - **Позитивно:** `gameState` є центральним джерелом правди для ігрової логіки. `stateManager` є єдиною точкою для мутацій стану, що є великим плюсом.
  - **До покращення:** Існує `localGameStore`, який дублює частину стану гравців та їх рахунку, що може призвести до розсинхронізації. Стан UI частково керується в `uiStore`, а частково — в самих компонентах.

- [ ] **UDF (Unidirectional Data Flow):** `80/100`
  - **Позитивно:** Використання Svelte stores сприяє односпрямованому потоку даних. Зміни стану ініціюються через сервіси (`gameLogicService`, `userActionService`) і розповсюджуються вниз до компонентів.
  - **До покращення:** Деякі компоненти напряму викликають `store.update()`, що може ускладнити відстеження потоку даних. Взаємодія між `gameLogicService` та `GameMode` класами іноді заплутана.

- [ ] **SoC (Separation of Concerns):** `75/100`
  - **Позитивно:** Є чіткий поділ на `services` (логіка), `stores` (стан) та `components` (UI). Використання класів `GameMode` для ізоляції логіки режимів гри є гарною практикою.
  - **До покращення:** `gameLogicService.ts` є занадто великим і містить як чисті функції для розрахунків, так і функції, що змінюють стан. Логіка, специфічна для UI (наприклад, `calculateFinalScore`), знаходиться в сервісі бізнес-логіки.

- [ ] **Композиція:** `90/100`
  - **Позитивно:** UI побудований з невеликих віджетів, які можна перетягувати (`DraggableColumns`). Це забезпечує високу гнучкість.
  - **До покращення:** Деякі віджети мають занадто багато відповідальностей.

- [ ] **Чистота та Побічні ефекти:** `70/100`
  - **Позитивно:** Більшість функцій в `gameLogicService` є чистими.
  - **До покращення:** `gameLogicService` має прямі залежності від `stateManager` та сторів, що робить його нечистим. Побічні ефекти (наприклад, `speakText`, `modalStore.showModal`) викликаються прямо з класів `GameMode`, що ускладнює тестування та відокремлення логіки.

### Якість Коду та Реалізації

- [ ] **DRY (Don't Repeat Yourself):** `65/100`
  - **Проблема:** Існує значне дублювання коду між `VsComputerGameMode.ts` та `LocalGameMode.ts` (наприклад, логіка `endGame`, `handlePlayerMove`, `claimNoMoves`).

- [ ] **Простота та Читабельність (KISS):** `70/100`
  - **Проблема:** `gameLogicService.ts` (понад 500 рядків) та `LocalGameMode.ts` (понад 300 рядків) є складними для розуміння. Функція `calculateMoveScore` має занадто багато параметрів та відповідальностей.
  - **Іменування:** В цілому добре, але деякі назви можуть бути більш точними (наприклад, `gameOrchestrator` тепер є псевдонімом для `userActionService`).

- [ ] **Продуктивність:** `80/100`
  - **Потенційна проблема:** Глибоке копіювання стану (`JSON.parse(JSON.stringify(currentState.players))`) в `calculateMoveScore` може бути неефективним при великій кількості гравців.
  - **Потенційна проблема:** Часті та неоптимізовані оновлення сторів можуть викликати зайві перерендери компонентів.

- [ ] **Документація та Коментарі:** `95/100`
  - **Позитивно:** Код добре документований. Коментарі пояснюють "навіщо", що є чудовою практикою.

## Частина 2: План Покращення

### Список Проблем та Пріоритети

| Пріоритет | Проблема                                                              | Важливість |
|-----------|-----------------------------------------------------------------------|------------|
| 1         | Дублювання коду між `VsComputerGameMode` та `LocalGameMode`           | `95/100`   |
| 2         | `gameLogicService` занадто великий і порушує SoC                      | `90/100`   |
| 3         | `localGameStore` дублює стан гравців                                  | `85/100`   |
| 4         | Прямі виклики побічних ефектів з `GameMode` класів                    | `80/100`   |
| 5         | Складна функція `calculateMoveScore`                                  | `70/100`   |
| 6         | Неефективне глибоке копіювання стану                                  | `60/100`   |

### План Дій

- [x] **Крок 1: Рефакторинг `GameMode` (Важливість: 95)**
  - [x] Створити базовий клас `BaseGameMode`, який буде містити спільну логіку для `endGame`, `handlePlayerMove`, `restartGame` і т.д.
  - [x] `VsComputerGameMode` та `LocalGameMode` мають успадковувати від `BaseGameMode` і перевизначати тільки унікальну для них логіку.
  - **Ціль:** Усунути дублювання коду, спростити додавання нових режимів.

- [x] **Крок 2: Розділення `gameLogicService` (Важливість: 90)**
  - [x] Створити новий сервіс `scoreService.ts` і перенести туди всю логіку, пов'язану з підрахунком балів (`calculateMoveScore`, `calculateFinalScore`).
  - [x] Чисті функції, що не залежать від стану (наприклад, `dirMap`, `numToDir`), винести в `utils/gameUtils.ts`.
  - **Ціль:** Покращити `SoC`, зменшити розмір `gameLogicService`, зробити код більш модульним.

- [ ] **Крок 3: Централізація стану гравців (Важливість: 85)**
  - [ ] Видалити `localGameStore` і перенести всю логіку управління гравцями (додавання, видалення, оновлення) в `gameState`.
  - [ ] `gameState` має бути єдиним джерелом правди для всіх гравців у всіх режимах.
  - **Ціль:** Забезпечити `SSoT` для стану гравців, уникнути розсинхронізації.

- [ ] **Крок 4: Ізоляція побічних ефектів (Важливість: 80)**
  - [ ] Створити `sideEffectService.ts`, який буде відповідати за всі побічні ефекти (модальні вікна, озвучення, анімації).
  - [ ] `GameMode` класи повинні повертати описи побічних ефектів, а не викликати їх напряму. `gameOrchestrator` (або новий сервіс) буде їх обробляти.
  - **Ціль:** Покращити чистоту коду, спростити тестування логіки.

- [ ] **Крок 5: Рефакторинг `calculateMoveScore` (Важливість: 70)**
  - [ ] Розбити функцію на кілька менших, кожна з яких відповідає за свій аспект (наприклад, `calculateMirrorMovePenalty`, `calculateJumpBonus`).
  - [ ] Використовувати більш ефективні методи оновлення стану замість глибокого копіювання (наприклад, `immer.js` або структуроване оновлення).
  - **Ціль:** Спростити логіку, покращити читабельність та продуктивність.