# Архітектурний План Покращення v16

## Частина 1: Комплексний Аудит Коду

### Архітектура та Структура

1.  **SSoT (Single Source of Truth):**
    *   **Оцінка: 75/100**
    *   **Аналіз:** `gameState` store є єдиним джерелом правди для основного стану гри, що є великим плюсом. Однак, існують похідні стани (derived state) та деякі UI-специфічні стани, які іноді управляються окремо, що може призвести до розсинхронізації.

2.  **UDF (Unidirectional Data Flow):**
    *   **Оцінка: 80/100**
    *   **Аналіз:** Потік даних в цілому односпрямований: UI викликає дії -> `GameMode` обробляє їх -> `gameLogicService` розраховує зміни -> `gameStateMutator` оновлює стан -> UI реагує на зміни. Це добре, але є моменти, де компоненти можуть напряму змінювати стан, минаючи встановлений потік.

3.  **SoC (Separation of Concerns):**
    *   **Оцінка: 70/100**
    *   **Аналіз:** Є гарний поділ між `gameLogicService` (чиста логіка), `gameStateMutator` (зміна стану) та `GameMode` (оркестрація). Однак, сам `gameState` store містить в собі логіку мутації стану (`addPlayer`, `resetScores`), що порушує SoC. Логіка візуалізації частково переплетена з ігровою логікою.

4.  **Композиція:**
    *   **Оцінка: 85/100**
    *   **Аналіз:** Використання компонентів Svelte для побудови UI є ефективним. Стратегія з `BaseGameMode` для ігрових режимів є чудовим прикладом композиції на рівні логіки.

5.  **Чистота та Побічні ефекти:**
    *   **Оцінка: 65/100**
    *   **Аналіз:** `gameLogicService` містить переважно чисті функції, що є сильною стороною. Однак, управління побічними ефектами (анімації, звуки, запити до API в майбутньому) не є централізованим. Вони розпорошені по різних частинах коду.

### Якість Коду та Реалізації

6.  **DRY (Don't Repeat Yourself):**
    *   **Оцінка: 70/100**
    *   **Аналіз:** Є дублювання коду, особливо в логіці обробки "немає ходів" та в деяких частинах UI. Можна винести повторювані частини в окремі функції або сервіси.

7.  **Простота та Читабельність (KISS):**
    *   **Оцінка: 80/100**
    *   **Аналіз:** Код в цілому добре структурований і читабельний. Іменування змінних та функцій є зрозумілим. Деякі функції, як `performMove`, є досить великими і їх можна було б розбити на менші.

8.  **Продуктивність:**
    *   **Оцінка: 90/100**
    *   **Аналіз:** На даний момент проблем з продуктивністю не спостерігається. Використання реактивності Svelte є ефективним. Потенційні проблеми можуть виникнути при збільшенні розміру дошки або ускладненні AI, але поточна архітектура дозволяє це оптимізувати.

9.  **Документація та Коментарі:**
    *   **Оцінка: 85/100**
    *   **Аналіз:** Код добре коментований. Коментарі пояснюють *навіщо* існують певні частини коду, що є дуже корисним. Особливо важливі попередження про можливі проблеми при рефакторингу.

## Частина 2: План Покращення

### Задачі для покращення архітектури

| Пріоритет (0-100) | Задача                                                                                                                              | Статус |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------ |
| **100**           | **[ ] Винести всю логіку мутації стану з `gameState.ts` в `gameStateMutator.ts`**                                                   |        |
| **95**            | **[ ] Створити `SideEffectService` для централізованого управління побічними ефектами (анімації, звуки, UI нотифікації)**           |        |
| **90**            | **[ ] Рефакторинг `performMove` для зменшення його розміру та винесення під-логік в окремі функції**                                 |        |
| **85**            | **[ ] Створити чіткий інтерфейс (API) для взаємодії між UI та ігровою логікою, щоб повністю унеможливити прямий доступ до стану з UI** |        |
| **80**            | **[ ] Впровадити `TimeService` для управління всією логікою, пов'язаною з часом (таймери ходу, загальний час гри)**                    |        |
| **75**            | **[ ] Уніфікувати обробку "немає ходів" для усунення дублювання коду**                                                                |        |
| **70**            | **[ ] Провести рефакторинг похідних станів (`derivedState.ts`) для їх оптимізації та уникнення зайвих обчислень**                     |        |

### План підготовки до масштабування

#### 1. Розширення ігрових режимів ("Гра онлайн")

-   [ ] **Створити `OnlineGameMode.ts`**, який буде наслідувати `BaseGameMode`.
-   [ ] **Створити `ApiService`** для взаємодії з сервером (WebSockets або HTTP).
-   [ ] **Адаптувати `gameState`** для зберігання стану, специфічного для онлайн гри (ID кімнати, стан з'єднання).
-   [ ] **Розширити `SideEffectService`** для обробки подій з сервера.

#### 2. Новий режим гри з обмеженням по часу

-   [ ] **Створити `TimedGameMode.ts`**, який буде наслідувати `VsComputerGameMode`.
-   [ ] **Інтегрувати `TimeService`** для відліку загального часу гри.
-   [ ] **Додати в `gameState`** поле для зберігання часу, що залишився.
-   [ ] **Оновити UI** для відображення таймера.

#### 3. Таймер на хід гравця

-   [ ] **Інтегрувати `TimeService`** в `BaseGameMode` для запуску/зупинки таймера ходу.
-   [ ] **Додати в `gameState`** поле для зберігання часу на хід.
-   [ ] **Розширити логіку `advanceToNextPlayer`** для скидання та запуску таймера.
-   [ ] **Додати в `BaseGameMode`** логіку завершення гри, якщо час на хід вийшов.

### Надважливі завдання (не поламати логіку)

-   **[ ] Ізоляція `game-board`:** Переконатися, що `game-board` отримує дані для візуалізації лише через props або спеціалізовані stores, і не має доступу до зміни `gameState`.
-   **[ ] Ізоляція `center-info`:** `center-info` має реагувати лише на зміни в `gameState` і не залежати від `game-board`.
-   **[ ] Увага до коментарів:** При рефакторингу звернути особливу увагу на коментарі-попередження в коді, щоб не зламати існуючу логіку.