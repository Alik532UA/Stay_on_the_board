# Комплексний план покращення архітектури (SoC) - v25

## Частина 1: Об'єднаний Аудит та Оцінка

### Критерій: SoC (Separation of Concerns)
Цей аудит поєднує аналіз з планів v23 та v24, щоб надати повну картину стану архітектури.

### Підсумкова оцінка SoC: 60 / 100

**Обґрунтування:**

*   **Сильні сторони (+):**
    *   **SSoT Foundation:** Стан гри централізовано в `gameState.ts`, що є гарною відправною точкою.
    *   **Ізоляція візуалізації:** "Золоте правило" проєкту виконується: логіка гри та `center-info` не залежать від візуалізації дошки.
    *   **Ізоляція Side Effects:** `sideEffectService` добре ізолює "брудні" операції (localStorage, навігація).
    *   **Логічна структура:** Проєкт має зрозумілу структуру папок (`stores`, `services`, `components`).

*   **Слабкі сторони (-):**
    1.  **Монолітний стан (`gameState.ts`):** Стор змішує в собі дані ядра гри, UI, кеш та специфічні для режимів поля. (з v23)
    2.  **"Божественний" сервіс (`gameLogicService.ts`):** Сервіс має забагато відповідальностей, що ускладнює його підтримку. (з v23)
    3.  **Логіка в UI-компонентах:** `game/+layout.svelte` містить бізнес-логіку обробки гарячих клавіш, що жорстко пов'язує UI та логіку. (з v24)
    4.  **Нечисті сервіси:** Сервіси напряму залежать від Svelte (`get(gameState)`), що робить їх непереносимими та важкими для тестування. (з v24)
    5.  **Стори з побічними ефектами:** `gameState` має логіку, що реагує на зміни в `testModeStore`. (з v24)
    6.  **Неізольована логіка режимів:** Логіка ігрових режимів розпорошена по різних сервісах. (з v23)

---

## Частина 2: Комплексний План Покращень

Цей план об'єднує тактичні кроки з v24 та стратегічні цілі з v23 у єдиний, поетапний roadmap.

### Фаза 1: Тактичні виправлення та підготовка

**Мета:** Швидко усунути найбільш кричущі порушення SoC та підготувати базу для глибокого рефакторингу.

- [ ] **1. Ізолювати логіку гарячих клавіш (з v24)**
    - **Пріоритет: 100**
    - [ ] Створити `src/lib/services/hotkeyService.ts`.
    - [ ] Повністю перенести логіку з `handleHotkey` та `executeAction` з `game/+layout.svelte` в `hotkeyService.ts`.
    - [ ] `game/+layout.svelte` повинен лише ініціалізувати сервіс в `onMount`.

- [ ] **2. Зробити сервіси "чистими" (з v24)**
    - **Пріоритет: 95**
    - [ ] Ввести правило: **сервіси логіки не повинні використовувати `get()`**. Вони мають отримувати стан як аргумент.
    - [ ] Модифікувати `performMove` та інші функції в `gameLogicService`, щоб вони приймали `currentState`.
    - [ ] Оновити `userActionService`, щоб він читав стан (`get(gameState)`) і передавав його в функції логіки.

- [ ] **3. Ізолювати логіку `testMode` (з v24)**
    - **Пріоритет: 90**
    - [ ] Створити `src/lib/services/testModeService.ts`.
    - [ ] Перенести логіку підписки на `testModeStore` з `gameState.ts` в `testModeService.ts`.
    - [ ] `testModeService` має оновлювати `gameState` через `gameStateMutator`.

### Фаза 2: Стратегічний рефакторинг ядра

**Мета:** Перебудувати ядро системи (стан та логіку) для забезпечення максимальної гнучкості та масштабованості.

- [ ] **4. Розділити монолітний `gameState` (з v23)**
    - **Пріоритет: 100**
    - [ ] Створити `boardStore.ts` (дані дошки: `board`, `playerRow`, `playerCol`, `cellVisitCounts`).
    - [ ] Створити `playerStore.ts` (гравці: `players`, `currentPlayerIndex`).
    - [ ] Створити `scoreStore.ts` (очки та бонуси).
    - [ ] Створити `uiState.ts` (стан UI: `isComputerMoveInProgress`, `selectedDirection`, `isGameOver`).

- [ ] **5. Розділити `gameLogicService` (з v23)**
    - **Пріоритет: 95**
    - [ ] Винести логіку валідації ходу в новий `moveValidationService.ts`.
    - [ ] Розширити `scoreService.ts` всією логікою, пов'язаною з розрахунком очок.
    - [ ] Створити `gameOrchestratorService.ts`, який буде керувати потоком гри, викликаючи інші, менші сервіси.

- [ ] **6. Впровадити єдину точку входу для дій (з v23/v24)**
    - **Пріоритет: 85**
    - [ ] Створити `inputService.ts` (або `CommandBus.ts`).
    - [ ] `hotkeyService` (з Фази 1) та всі UI-компоненти (кнопки напрямків, підтвердження ходу) повинні викликати методи цього сервісу (напр., `inputService.confirmMove()`).
    - [ ] `inputService` транслює ці наміри у виклики `userActionService` або `gameOrchestratorService`.

### Фаза 3: Впровадження архітектури режимів

**Мета:** Створити систему, що дозволяє легко додавати нові ігрові режими.

- [ ] **7. Реалізувати патерн "Стратегія" для ігрових режимів (з v23)**
    - **Пріоритет: 90**
    - [ ] Створити базовий інтерфейс `IGameMode` (`onMove`, `onGameStart`, `onGameEnd` і т.д.).
    - [ ] Створити конкретні реалізації: `TrainingMode.ts`, `LocalGameMode.ts`, `TimedMode.ts`.
    - [ ] `gameModeService` має відповідати лише за завантаження та перемикання між режимами, а не за їхню логіку.
    - [ ] Нові сервіси (напр., `TimerService`) мають керуватися активним режимом.
