# План покращення архітектури v19

## Частина 1: Комплексний аудит коду

| Критерій | Оцінка (0-100) | Коментар |
| :--- | :--- | :--- |
| **Архітектура та Структура** | | |
| 1. **SSoT (Single Source of Truth)** | 85 | `gameState` є єдиним джерелом правди для логічного стану, що є великим плюсом. Проте, існують інші стори (`playerInputStore`, `appSettingsStore`), які іноді дублюють або тісно пов'язані з `gameState`. |
| 2. **UDF (Unidirectional Data Flow)** | 90 | Потік даних добре організований: `userActionService` -> `GameMode` -> `gameLogicService` -> `gameStateMutator` -> `gameState`. UI реагує на зміни в сторах. |
| 3. **SoC (Separation of Concerns)** | 80 | Розділення відповідальності в цілому добре: сервіси для логіки, стори для стану, компоненти для UI. Однак, `gameLogicService` має деякі обов'язки, які можна було б винести (наприклад, логіка ходу комп'ютера). |
| 4. **Композиція** | 75 | Компоненти використовуються для побудови UI, але деякі з них є занадто великими і могли б бути розбиті на менші, більш перевикористовувані частини. |
| 5. **Чистота та Побічні ефекти** | 70 | `gameLogicService` містить переважно чисті функції, але є залежності від сторів (`get(gameState)`), що ускладнює тестування. Побічні ефекти (анімації, модальні вікна) керуються, але їх можна було б ізолювати краще. |
| **Якість Коду та Реалізації** | | |
| 6. **DRY (Don't Repeat Yourself)** | 75 | Є дублювання коду, особливо в логіці обробки ходів у різних режимах гри. `BaseGameMode` допомагає, але деякі частини все ще повторюються. |
| 7. **Простота та Читабельність (KISS)** | 80 | Код в цілому читабельний, але деякі функції (особливо в `gameLogicService`) є досить великими і складними. Іменування змінних та функцій добре. |
| 8. **Продуктивність** | 85 | Наразі проблем з продуктивністю не спостерігається. Використання реактивних сторів Svelte є ефективним. Потенційні проблеми можуть виникнути при збільшенні розміру дошки або складності логіки. |
| 9. **Документація та Коментарі** | 70 | Коментарі є, але вони не завжди пояснюють *навіщо* щось робиться. JSDoc використовується, але не скрізь. |

---

## Частина 2: План покращення

### Пріоритезований список проблем та завдань

| Пріоритет (0-100) | Завдання | Опис |
| :--- | :--- | :--- |
| **95** | [x] **Рефакторинг `gameLogicService`** | Розділити `performMove` на менші, більш чисті функції. Винести логіку ходу комп'ютера в окремий сервіс `aiService`. Це спростить тестування та розуміння коду. <br> - [x] Винести логіку ходу комп'ютера в окремий сервіс `aiService`. <br> - [x] Розділити `performMove` на менші, більш чисті функції. |
| **90** | [x] **Централізація стану в `gameState`** | Перенести стан з `playerInputStore` (напрямок, відстань) в `gameState`. Це забезпечить єдине джерело правди для всього ігрового стану. |
| **85** | [x] **Ізоляція побічних ефектів** | Створити `animationService` для управління всіма анімаціями. `gameLogicService` та `GameMode` повинні лише повертати опис змін, а не викликати анімації напряму. |
| **80** | [x] **Покращення композиції компонентів** | Розбити великі компоненти (наприклад, `GameBoard`) на менші, такі як `Cell`, `PlayerPiece`. Це покращить перевикористання та тестування. |
| **75** | [x] **Видалення дублювання в `GameMode`** | Створити більше спільних методів в `BaseGameMode` для усунення дублювання коду в дочірніх класах (наприклад, обробка успішного/невдалого ходу). |
| **70** | [ ] **Покращення документації** | Додати JSDoc до всіх публічних методів сервісів та сторів. Переглянути існуючі коментарі, щоб вони пояснювали *навіщо*, а не *що*. |
| **60** | [ ] **Впровадження TypeScript** | Поступово мігрувати проект на TypeScript для покращення надійності та підтримки коду в майбутньому. |

### Важливі зауваження

- **Не зламати логіку:**
  - [ ] Візуалізація дошки (`game-board`) не повинна впливати на `center-info` та на логіку гри.
  - [ ] `center-info` та логіка гри не повинна знати про візуалізацію дошки (`game-board`).
  - [ ] Логіка гри не повинна знати та залежати від візуалізації на дошці.
- **Взяти до уваги попередження в коді:**
  - [ ] Проаналізувати всі `TODO` та коментарі-попередження в коді та врахувати їх під час рефакторингу.