---
id: PATTERN-001
title: 'Архітектурний Патерн: Асинхронна Візуалізація Стану'
status: done
created: 2025-07-22
last-reviewed: 2025-08-07
---

**Пов'язані документи:**
- [Архітектура ігрового циклу та потоку даних](GAME_LOGIC_AND_DATA_FLOW.md)
- [Center Info Element](../elements/CENTER_INFO_ELEMENT.md)
- [Архітектура проєкту](../ARCHITECTURE.md)

## Архітектурний Патерн: Асинхронна Візуалізація Стану

Цей документ описує патерн, що використовується в проєкті для надійного розділення ігрової логіки та її асинхронного візуального представлення (анімацій).

### 1. Проблема: Стан гонитви (Race Condition)

При розробці інтерактивних систем, де логічний стан оновлюється швидко, а візуалізація потребує часу (наприклад, для анімації), виникає фундаментальна проблема.

**Неправильний підхід:** Змішування логіки та анімації за допомогою `async/await` та `setTimeout` безпосередньо в функціях, що змінюють стан (`gameOrchestrator.js`).

**Наслідки:**
- **Блокування логіки:** Ігровий цикл зупиняється, очікуючи завершення анімації. Користувач не може виконувати дії, поки UI "наздоганяє".
- **Стан гонитви:** Швидкі послідовні оновлення стану призводять до того, що UI-компонент отримує кілька оновлень одночасно і може відрендерити лише кінцевий стан, пропускаючи проміжні. Це призводило до того, що анімація ходу гравця пропускалася.
- **Ненадійність:** Логіка стає залежною від таймінгів `setTimeout`, що робить її крихкою та складною для тестування.

### 2. Архітектурне Рішення: Повне Розділення Відповідальностей

Ми реалізували патерн **"Асинхронна Візуалізація на Основі Черги"**, який базується на принципі "мозок працює миттєво, очі наздоганяють плавно".

1.  **Логічний Стан (Мозок):** Усі зміни в `gameState` відбуваються **миттєво та синхронно**. Жодних `setTimeout` чи `await` для анімацій у файлах `gameOrchestrator.js` або `gameActions.ts`.
2.  **UI-компонент (Очі):** Компонент, що відповідає за візуалізацію (`BoardWrapperWidget.svelte`), є **єдиним власником логіки анімації**. Він лише *спостерігає* за змінами в логічному стані.
3.  **Черга Подій (Міст):** `gameState.moveQueue` слугує мостом між логікою та UI. Логіка миттєво додає в чергу виконані ходи. UI читає цю чергу і послідовно їх "відтворює" візуально.

### 3. Ключові Компоненти Реалізації

#### а) `gameState.moveQueue`
- Це масив, що зберігає послідовність виконаних ходів.
- Він є сигналом для UI, що з'явилася нова "робота" для візуалізації.

#### б) Компонент `BoardWrapperWidget.svelte`
- **Локальний візуальний стан:** Компонент має власні, локальні змінні для координат ферзя, оголошені через `$state`, щоб бути реактивними:
  ```typescript
  let visualRow = $state($gameState.playerRow);
  let visualCol = $state($gameState.playerCol);
  ```
- **Керуючі змінні:** Змінні, що керують процесом анімації, є звичайними `let`, оскільки їх зміна не повинна напряму викликати перерендер:
  ```typescript
  let lastProcessedMoveIndex = 0;
  let isAnimating = false;
  ```
- **Реактивний тригер (`$effect`):** Цей блок відстежує зміни в `gameState` і запускає чергу анімацій лише тоді, коли це потрібно (з'явилися нові ходи, і анімація наразі не активна). Він також відповідає за скидання візуального стану при старті нової гри.
- **Рекурсивна функція анімації (`processAnimationQueue`):**
  - Обробляє **один** хід з черги.
  - Оновлює `visualRow`/`visualCol`, що запускає CSS-анімацію.
  - **Критично важливо:** Планує свій наступний виклик через `setTimeout`, і **тільки всередині цього `setTimeout`** інкрементує лічильник `lastProcessedMoveIndex`. Це усуває стан гонитви.

#### г) Принцип "Спочатку дій, потім перевіряй наслідки"

Для коректної візуалізації всіх ходів, включно з програшними, логіка має дотримуватися цього принципу.

- **Неправильно:** Перевіряти, чи буде хід програшним, *до* оновлення стану. Це призводить до того, що програшний хід ніколи не записується в стан і, відповідно, не анімується.
- **Правильно:** Завжди оновлювати стан гри (`gameState`, `moveQueue`) на основі дії користувача. І лише *після* цього оновлення перевіряти, чи призвів новий стан до завершення гри. Це гарантує, що UI завжди матиме дані для анімації останнього ходу.

### 4. Схема Потоку Даних

```
[Дія гравця] -> [gameOrchestrator] -> [gameState ОНОВЛЕНО МИТТЄВО]
                                           |
       +-----------------------------------+-----------------------------------+
       | (Миттєве читання)                 | (Реактивне відстеження)            |
       V                                   V                                   V
[ControlsPanelWidget]               [Доступні ходи]                     [BoardWrapperWidget]
(Оновлює center-info)               (Перераховуються)                   (Запускає власну,
                                                                         незалежну чергу
                                                                         анімацій з паузами)
```

### 5. Майбутні Рекомендації

При реалізації будь-якої функціональності, що вимагає асинхронних візуальних ефектів у відповідь на зміни стану, дотримуйтесь цих правил:

1.  **Логіка — завжди синхронна:** Файли, що відповідають за логіку (`stores`, `services`), не повинні містити `setTimeout` або `await` для цілей анімації.
2.  **UI — власник анімації:** Уся логіка, пов'язана з візуальними затримками, має бути інкапсульована всередині відповідного UI-компонента.
3.  **Використовуйте чергу подій:** Якщо потрібно відтворити послідовність подій, додавайте їх у масив (чергу) в `gameState`, а UI-компонент нехай обробляє цю чергу у власному темпі.
4.  **Розділяйте стан:** Чітко розрізняйте логічний стан (в `gameState`) та локальний візуальний стан (в компоненті). Синхронізуйте їх за допомогою реактивних механізмів (`$effect`). 

## Незалежність анімації дошки та миттєве оновлення center-info

- Логіка гри (gameState, moveQueue) оновлюється миттєво та синхронно.
- ControlsPanelWidget (center-info, control-btn, computer-move-display) миттєво реагує на зміни стану гри, незалежно від анімації дошки.
- BoardWrapperWidget має власну чергу анімацій:
  1. Анімує хід гравця (фігура рухається на нову позицію).
  2. Чекає паузу (наприклад, 1 секунда).
  3. Анімує хід комп'ютера (фігура рухається на нову позицію).
- Цей процес не блокує логіку гри та не впливає на ControlsPanelWidget.
- ControlsPanelWidget підписується лише на логічний стан (lastComputerMove, centerInfo) і оновлюється миттєво після зміни стану гри. 