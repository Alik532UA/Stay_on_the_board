# Основні концепції: Керування станом

Цей документ пояснює філософію та принципи керування станом у проєкті "Stay on the Board".

## 1. Філософія: від Моноліту до Гранулярності

Спочатку стан гри зберігався в одному великому об'єкті `gameState`. Це було просто, але з ростом функціоналу призвело до кількох проблем:

- **Висока зв'язаність (High Coupling):** Компоненти, яким потрібна була лише маленька частина стану (наприклад, колір теми), змушені були підписуватися на весь `gameState`, що призводило до зайвих ре-рендерів.
- **Складність керування:** Будь-яка зміна в будь-якій частині стану вимагала оновлення гігантського об'єкта, що ускладнювало логіку та підвищувало ризик помилок.
- **Нечіткі зони відповідальності:** Було незрозуміло, яка частина коду за яку частину стану відповідає.

Щоб вирішити ці проблеми, ми перейшли до **гранулярної архітектури**, розділивши `gameState` на декілька незалежних, логічно пов'язаних сторів.

**Основний принцип:** Кожен стор є єдиним джерелом правди (SSoT) для своєї конкретної зони відповідальності.

## 2. Класифікація Сторів

Ми розділили стани на три основні категорії:

### А. Стан Ігрової Сесії (`gameSettingsStore`, `boardStore`, `playerStore`, `scoreStore`)
Це дані, що стосуються **конкретної партії**. Вони ініціалізуються на початку гри і скидаються, коли гра завершується.

- **`gameSettingsStore` vs `appSettingsStore`:** Це ключове розділення.
    - **`gameSettingsStore`** містить налаштування, які гравець обирає *для поточної гри* (розмір дошки, режим гри). Якщо почати нову гру, ці налаштування можна змінити.
    - **`appSettingsStore`** містить глобальні налаштування *застосунку* (тема, мова). Вони не залежать від ігрової сесії і зберігаються між візитами (`localStorage`).

### Б. Стан Застосунку (`appSettingsStore`, `uiStateStore`)
Це дані, що визначають загальну поведінку та вигляд застосунку, незалежно від того, чи триває гра.

### В. Стан UI (`uiStateStore`)
Цей стор керує тимчасовими станами інтерфейсу, такими як відкриті модальні вікна, сповіщення, індикатори завантаження тощо.

## 3. Життєвий цикл дії: "Гравець робить хід"

Розглянемо, як оновлюються стори на прикладі ходу гравця:

1.  **UI Layer:** Користувач клікає на клітинку на дошці. Компонент `Board.svelte` викликає метод з `GameOrchestrator`, наприклад, `gameOrchestrator.handlePlayerMove({ x, y })`.

2.  **Service Layer (`GameOrchestrator`):**
    - Отримує поточний стан з `playerStore` (щоб перевірити, чи зараз хід гравця) та `boardStore` (поточна позиція).
    - Викликає чисту функцію з `GameLogicService` для валідації ходу, наприклад, `isValid = gameLogicService.validateMove(...)`.

3.  **Service Layer (`GameLogicService`):**
    - Якщо хід валідний, `GameLogicService` повертає новий стан для відповідних частин системи. Він не змінює стори напряму.

4.  **Service Layer (`GameOrchestrator`):**
    - Отримавши новий стан, оркестратор оновлює відповідні стори:
        - **`boardStore.update(...)`**: оновлює позицію фігури та додає стару позицію до заблокованих клітинок.
        - **`playerStore.update(...)`**: змінює `currentPlayer` на "Computer".
        - **`scoreStore.update(...)`**: додає хід до історії та оновлює рахунок.

5.  **UI Layer (Реактивність):**
    - Компоненти, підписані на `boardStore`, `playerStore` та `scoreStore`, автоматично оновлюються, щоб відобразити новий стан. Наприклад, `Board.svelte` перемальовує фігуру на новій позиції, а `InfoPanel.svelte` показує, що тепер хід VirtualPlayer.

Цей підхід гарантує, що кожен компонент реагує лише на ті зміни, які його стосуються, роблячи систему більш ефективною та передбачуваною.