---
id: ARCH-001
title: 'Архітектура Ігрового Циклу та Потоку Даних'
status: pending
created: 2025-07-22
last-reviewed: 2025-08-07
---

**Пов'язані документи:**
- [Архітектура проєкту](../ARCHITECTURE.md)
- [Патерни асинхронної візуалізації стану](PATTERNS-asynchronous-state-visualization.md)
- [Center Info Element](../elements/CENTER_INFO_ELEMENT.md)

## Архітектура Ігрового Циклу та Потоку Даних

Цей документ описує ключові архітектурні принципи, що регулюють ігровий процес, обробку ходів та їх візуалізацію. Дотримання цих принципів є критично важливим для уникнення станів гонитви (race conditions) та забезпечення стабільності гри.

### 1. Основні Принципи

1.  **Розділення Відповідальностей (Separation of Concerns):** Логіка гри повністю відокремлена від її візуального представлення (UI).
2.  **Єдине Джерело Правди (Single Source of Truth):** `gameState.ts` є єдиним і непорушним джерелом правди про поточний стан гри.
3.  **Односпрямований Потік Даних (Unidirectional Data Flow):** Зміни стану ініціюються діями користувача, проходять через оркестратор та екшени, оновлюють стан, і лише потім UI реагує на ці зміни.
4.  **Миттєва Логіка, Асинхронний UI:** Усі зміни в логічному стані гри відбуваються **миттєво та синхронно**. Усі візуальні затримки (анімації) інкапсульовані виключно в UI-компонентах і не блокують логіку.

### 2. Ключові Учасники Процесу

-   **`gameState.ts` (Серце):** Зберігає весь логічний стан: координати, рахунок, історію, чергу ходів (`moveQueue`) тощо.
-   **`gameActions.ts` (М'язи):** Єдине місце, де відбувається **мутація** стану `gameState`. Містить чисті функції, що приймають дані та оновлюють стор.
-   **`gameOrchestrator.js` (Мозок):** Координує ігровий процес. Він читає стан, приймає рішення (наприклад, перевіряє на програш, викликає хід комп'ютера) і викликає відповідні функції з `gameActions.ts` для зміни стану. Сам оркестратор є stateless.
-   **UI Компоненти (Очі та Руки):**
    -   `ControlsPanelWidget.svelte`: Приймає ввід від користувача і викликає функції з `gameOrchestrator`. Миттєво реагує на зміни стану (наприклад, показує хід комп'ютера).
    -   `BoardWrapperWidget.svelte`: Відповідає **виключно** за візуалізацію дошки та анімацію ферзя. Спостерігає за станом і відтворює його з візуальними затримками.

### 3. Детальний Опис Ігрового Циклу (Хід Гравця -> Хід Комп'ютера)

1.  **Дія Гравця:** Користувач обирає напрямок/відстань і натискає "Підтвердити" в `ControlsPanelWidget`.

2.  **Виклик Оркестратора:** Компонент викликає `confirmPlayerMove()` з `gameOrchestrator.js`.

3.  **Принцип "Спочатку Дій, Потім Перевіряй":**
    -   `confirmPlayerMove` **негайно** викликає `gameActions` (`performMove`, `processPlayerMove`), щоб оновити `gameState`.
    -   Новий хід додається до `gameState.moveQueue`.
    -   Логічні координати ферзя (`playerRow`, `playerCol`) оновлюються.

4.  **Перевірка Наслідків:**
    -   **Після** оновлення стану, `confirmPlayerMove` перевіряє, чи є нова позиція програшною.
    -   **Сценарій А (Програш):**
        -   Викликається `endGame(reason)`, яка **лише** встановлює прапорець `isGameOver: true` та причину в `gameState`.
        -   Функція завершується. **Хід комп'ютера не викликається.**
    -   **Сценарій Б (Валідний хід):**
        -   Викликається `triggerComputerMove()`.

5.  **Хід Комп'ютера:**
    -   `triggerComputerMove` отримує хід від AI.
    -   Він **негайно** викликає `gameActions` для оновлення `gameState` (координати, рахунок, `moveQueue`).

6.  **Реакція UI (відбувається паралельно):**
    -   `ControlsPanelWidget` миттєво бачить оновлення `computerLastMoveDisplayStore` і показує хід комп'ютера.
    -   `BoardWrapperWidget` через `$effect` бачить, що `moveQueue` збільшився. Він запускає **свою власну, незалежну чергу анімацій**:
        -   Він анімує перший новий хід (гравця).
        -   Чекає `setTimeout`.
        -   Анімує другий новий хід (комп'ютера).
        -   Цей процес **не блокує** логіку гри чи інші UI-компоненти.

### 4. Схема Потоку

```
[Дія гравця] -> [Orchestrator] -> [Actions] -> [gameState ОНОВЛЕНО]
                                                    |
       +--------------------------------------------+--------------------------------------------+
       | (Миттєве читання)                          | (Реактивне відстеження)                     |
       V                                            V                                            V
[ControlsPanelWidget]                        [Доступні ходи]                              [BoardWrapperWidget]
(Оновлює center-info)                        (Перераховуються)                            (Запускає власну,
                                                                                          незалежну чергу
                                                                                          анімацій з паузами)
```

Ця архітектура гарантує, що логіка гри залишається чистою, швидкою та передбачуваною, а всі складні асинхронні візуальні ефекти інкапсульовані у відповідних UI-компонентах. 