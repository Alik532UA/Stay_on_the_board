
### **План виправлення Bug #25 (Ревізія 2): Коректне накопичення заблокованих клітинок**

**Мета:** Виправити логіку в централізованій функції `performMove`, щоб забезпечити правильне накопичення та відображення заблокованих клітинок протягом гри.

**Стратегія:** Модифікувати функцію `performMove` у файлі `src/stores/gameStore.js`, щоб вона правильно додавала попередню позицію гравця до списку заблокованих клітинок, не втрачаючи при цьому існуючі.

---

#### **Крок 1: Виправлення логіки у функції `performMove`**

Ми не будемо змінювати ні `confirmMove`, ні `makeComputerMove`, оскільки вони вже використовують наш централізований хелпер. Вся проблема знаходиться всередині `performMove`.

**Дія:** У файлі `src/stores/gameStore.js` знайди функцію `performMove`, яку ми створили на попередньому кроці, і **повністю заміни її** на наступну виправлену версію:

```javascript
/**
 * Виконує переміщення фігури та повертає оновлені частини стану.
 * Ця функція є єдиним джерелом правди для логіки ходу.
 * @param {AppState} state - Поточний стан гри.
 * @param {number} newRow - Новий рядок для фігури.
 * @param {number} newCol - Новий стовпець для фігури.
 * @returns {Partial<AppState>} Об'єкт з оновленими частинами стану.
 */
function performMove(state, newRow, newCol) {
  const { board, playerRow, playerCol, boardSize, blockModeEnabled, visitedCells, blockedCells } = state;

  // 1. Створюємо копію дошки та переміщуємо фігуру
  const newBoard = board.map(row => row.slice());
  newBoard[playerRow][playerCol] = 0;
  newBoard[newRow][newCol] = 1;

  // 2. Оновлюємо відвідані та заблоковані клітинки
  let newVisitedCells = [...visitedCells];
  let newBlockedCells = [...blockedCells];

  if (blockModeEnabled) {
    const prevCell = { row: playerRow, col: playerCol };

    // **КЛЮЧОВЕ ВИПРАВЛЕННЯ:** Додаємо попередню клітинку до списку заблокованих,
    // якщо її там ще немає. Це забезпечує накопичення.
    if (!newBlockedCells.some(c => c.row === prevCell.row && c.col === prevCell.col)) {
      newBlockedCells.push(prevCell);
    }
    
    // Оновлюємо також і visitedCells для консистентності, хоча основна логіка тепер
    // залежить від newBlockedCells.
    if (!newVisitedCells.some(c => c.row === prevCell.row && c.col === prevCell.col)) {
        newVisitedCells.push(prevCell);
    }
  }

  // 3. Розраховуємо нові доступні ходи, використовуючи оновлений список блокувань
  const newAvailableMoves = getAvailableMoves(newRow, newCol, boardSize, newBlockedCells);

  return {
    board: newBoard,
    playerRow: newRow,
    playerCol: newCol,
    blockedCells: newBlockedCells,
    visitedCells: newVisitedCells,
    availableMoves: newAvailableMoves,
  };
}
```

**Обґрунтування виправлення:**

1.  **Правильне накопичення:** Замість того, щоб перезаписувати `newBlockedCells` на кожному кроці, ми тепер стартуємо з копії існуючого масиву (`let newBlockedCells = [...blockedCells];`) і додаємо до нього попередню позицію гравця (`newBlockedCells.push(prevCell);`). Це гарантує, що історія блокувань зберігається протягом всієї гри.
2.  **Надійність:** Логіка тепер проста і прямолінійна. Вона коректно працює як для ходу гравця, так і для ходу комп'ютера, оскільки обидва використовують цю єдину, виправлену функцію.
3.  **Без зайвих змін:** Інші частини коду (`confirmMove`, `makeComputerMove`) залишаються незмінними, що демонструє перевагу централізованої логіки — виправлення в одному місці вирішує проблему скрізь.

Після застосування цієї зміни, клітинки, на яких побувала фігура, будуть коректно додаватися до стану `blockedCells` і, як наслідок, правильно зафарбовуватися в чорний колір на ігровій дошці, незалежно від того, хто зробив хід.