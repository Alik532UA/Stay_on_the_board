# Архітектурний план поліпшення: Separation of Concerns (SoC) - v23

## Частина 1: Комплексний аудит коду

### Критерій: SoC (Separation of Concerns)
Аналіз того, наскільки добре в проєкті розділені відповідальності: стан (State), логіка (Logic) та користувацький інтерфейс (UI).

### Поточна оцінка: 55/100

**Обґрунтування:**

*   **Сильні сторони (+):**
    *   **Централізований стан:** Основний стан гри знаходиться у Svelte сторі (`gameState`), що є гарною практикою.
    *   **Ізоляція "брудних" функцій:** `sideEffectService` відмінно ізолює операції, що не відносяться до чистої логіки (навігація, робота з `localStorage`, модальні вікна). Це значне досягнення для SoC.
    *   **Декларативний UI:** Компоненти Svelte переважно відповідають за відображення даних зі сторів, а не за зберігання чи обробку складної бізнес-логіки.

*   **Слабкі сторони (-):**
    *   **Монолітний стан (`gameState.ts`):** Об'єкт `GameState` став занадто великим і змішує в собі все: дані дошки, стан UI (`isComputerMoveInProgress`), кеш (`availableMoves`), дані, специфічні для режимів, та поля для розрахунку очок.
    *   **"Божественний" сервіс (`gameLogicService.ts`):** Цей сервіс взяв на себе забагато відповідальностей: валідація ходів, розрахунок нової позиції, розрахунок очок, оновлення стану. Це робить його складним для розуміння та модифікації.
    *   **Нечіткі межі відповідальності:** Логіка, що відповідає за різні ігрові режими (тренування, гра на час), не інкапсульована в окремих модулях, а розпорошена по сервісах у вигляді умовних перевірок. Це значно ускладнить додавання нових режимів.

---

## Частина 2: План поліпшень

### Головна мета: Підготувати код до масштабування

Ключові завдання:
1.  **Додавання логіки режимів та таймера:** ('docs/plans/modes-and-timer-logic-plan.md')
2.  **Розширення до онлайн-режиму:** ('docs/plans/Migrating-to-Firebase-for-online-mode.md')
3.  **Впровадження системи нагород:** ('docs/plans/rewards-plan.md')

### Список проблем та пріоритети для їх вирішення

| Пріоритет (0-100) | Проблема                                                                                              | Рішення                                                                                                                                                                 |
| :---------------- | :---------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **100**           | Монолітний стан `gameState` змішує дані ядра гри, UI та різних режимів.                                | Розділити `gameState` на кілька спеціалізованих сторів: `boardState`, `playerState`, `scoreState`, `uiState`.                                                          |
| **95**            | `gameLogicService` є "божественним" об'єктом, що порушує принцип єдиної відповідальності.               | Рефакторинг `gameLogicService`. Винести логіку в окремі сервіси: `moveValidationService`, `positionCalculationService`, `scoreService`.                                  |
| **90**            | Логіка ігрових режимів не ізольована.                                                                 | Створити чітку архітектуру для ігрових режимів (наприклад, за допомогою патерну "Стратегія"), де кожен режим (`TrainingMode`, `TimedMode`) має власну реалізацію логіки. |
| **85**            | Прямий виклик мутаторів стану з UI-компонентів або сервісів.                                           | Впровадити чіткий потік команд (Command Bus) або дій (Actions), щоб UI лише виражав намір ("хочу зробити хід"), а не змінював стан напряму.                           |
| **70**            | Недостатньо чітке розділення між візуалізацією дошки (`game-board`) та станом гри (`center-info`).     | Переконатися, що UI компоненти отримують дані лише зі сторів і не мають прямого доступу до сервісів логіки. Всі взаємодії мають іти через систему команд/дій.        |

### План дій (Roadmap)

#### Фаза 1: Рефакторинг стану та логіки (основа для масштабування)

-   [ ] **Розділення `gameState`:**
    -   [ ] Створити `boardStore.ts` для стану дошки (`board`, `playerRow`, `playerCol`, `cellVisitCounts`).
    -   [ ] Створити `playerStore.ts` для гравців (`players`, `currentPlayerIndex`).
    -   [ ] Створити `scoreStore.ts` для стану очок та бонусів.
    -   [ ] Створити `uiState.ts` для стану інтерфейсу (`isComputerMoveInProgress`, `selectedDirection`).
-   [ ] **Рефакторинг `gameLogicService`:**
    -   [ ] Винести логіку валідації ходу в новий `moveValidationService.ts`.
    -   [ ] Перенести функції, пов'язані з розрахунком очок, у `scoreService.ts` і розширити його.
    -   [ ] Створити `gameOrchestratorService.ts`, який буде керувати потоком гри, викликаючи інші сервіси.
-   [ ] **Ізоляція логіки режимів:**
    -   [ ] Створити базовий інтерфейс `IGameMode` (`onMove`, `onGameStart`, `onGameEnd`).
    -   [ ] Створити конкретні реалізації: `TrainingMode.ts`, `LocalGameMode.ts`.
    -   [ ] `gameModeService` має завантажувати та активувати потрібний режим, а не містити логіку.

#### Фаза 2: Впровадження нової логіки на основі покращеної архітектури

-   [ ] **Реалізація логіки таймерів:**
    -   [ ] Створити `TimerService.ts`, який буде керуватися активним ігровим режимом.
    -   [ ] Реалізувати `TimedMode.ts`, який буде використовувати `TimerService` згідно з планом.
-   [ ] **Підготовка до онлайн-режиму:**
    -   [ ] Створити `OnlineGameMode.ts`, який буде взаємодіяти з `firebaseService` (згідно з планом міграції).
    -   [ ] Переконатися, що синхронізується лише необхідний стан (дані з `boardStore`, `playerStore`), а не UI-стан.
-   [ ] **Підготовка до системи нагород:**
    -   [ ] Створити `rewardsService.ts`, який буде підписуватися на зміни в сторах (`scoreStore`, `playerStore`) і перевіряти умови для нагород.