# Архітектурний План Покращення v15

## Частина 1: Комплексний Аудит Коду

Цей аудит оцінює поточний стан коду за ключовими архітектурними критеріями для підготовки до масштабування та додавання нового ігрового режиму "Гра онлайн".

### Архітектура та Структура

1.  **[ ] SSoT (Single Source of Truth):** 90/100
    *   **Оцінка:** Дуже добре. Стор `gameState` є єдиним джерелом правди для стану гри. Це значно спрощує логіку та запобігає розсинхронізації даних.
    *   **Проблеми:** Немає критичних проблем.

2.  **[ ] UDF (Unidirectional Data Flow):** 75/100
    *   **Оцінка:** Добре, але є недоліки. Існує `gameStateMutator`, що є правильною спробою створити односпрямований потік (UI -> Mutator -> Store -> UI). Однак, сам стор `gameState` також експортує власні методи для мутацій (`addPlayer`, `updateSettings`), що створює другий, паралельний шлях для зміни стану, минаючи мутатор.
    *   **Проблеми:** Подвійний шлях мутації стану може призвести до плутанини та помилок у майбутньому.

3.  **[ ] SoC (Separation of Concerns):** 95/100
    *   **Оцінка:** Відмінно. Чітко розділено відповідальності:
        *   **Стан:** `gameState.ts`
        *   **Логіка:** `gameStateMutator.ts` (та інші сервіси, ймовірно)
        *   **UI:** Компоненти (`BoardWrapperWidget`, `GameInfoWidget`) є переважно "чистими" і реагують на зміни стану, не містять ігрової логіки.
    *   **Проблеми:** Немає критичних проблем. Архітектура добре підготовлена до ізоляції логіки від візуалізації.

4.  **[ ] Композиція:** 90/100
    *   **Оцінка:** Дуже добре. Сторінка `vs-computer/+page.svelte` є чудовим прикладом композиції UI з незалежних віджетів. Це дозволяє легко перекомпоновувати UI для різних режимів гри.
    *   **Проблеми:** Немає.

5.  **[ ] Чистота та Побічні ефекти:** 85/100
    *   **Оцінка:** Добре. Побічні ефекти, такі як анімації, ізольовані в `animationStore`. Коментар у `BoardWrapperWidget.svelte` підтверджує, що затримки є виключно візуальними і не впливають на логіку гри, що є критично важливим.
    *   **Проблеми:** Немає.

### Якість Коду та Реалізації

6.  **[ ] DRY (Don't Repeat Yourself):** 80/100 (Попередня оцінка)
    *   **Оцінка:** Добре. У межах переглянутих файлів значного дублювання не виявлено. Однак, методи `addPlayerBonus` та `addPlayerPenalty` в `gameState.ts` дуже схожі.
    *   **Проблеми:** Можливе незначне дублювання логіки, яке можна рефакторити.

7.  **[ ] Простота та Читабельність (KISS):** 85/100
    *   **Оцінка:** Добре. Код добре структурований, іменування змінних та функцій є зрозумілим. Використання derived stores для обчислення похідних даних (`displayMessage`) спрощує компоненти.
    *   **Проблеми:** Метод `gameStateMutator.applyMove` приймає `Partial<GameState>`, що є занадто загальним і приховує *намір* зміни. Більш конкретні методи (наприклад, `movePlayer(...)`) були б кращими.

8.  **[ ] Продуктивність:** 90/100 (Попередня оцінка)
    *   **Оцінка:** Дуже добре. Використання сторів Svelte та похідних сторів забезпечує ефективні оновлення UI без зайвих перерендерів. Ізоляція анімацій від стану гри також є плюсом для продуктивності.
    *   **Проблеми:** На даний момент не виявлено.

9.  **[ ] Документація та Коментарі:** 95/100
    *   **Оцінка:** Відмінно. Коментарі в коді дуже корисні та пояснюють *навіщо* (архітектурні рішення), а не *що* робить код. Це надзвичайно цінно для підтримки та розвитку проєкту.

## Частина 2: План Покращення

Мета: Підготувати архітектуру до легкого додавання нових ігрових режимів, зокрема "Гра онлайн", зберігши поточну логіку та ізоляцію компонентів.

### Список Завдань та Пріоритети

| Пріоритет (0-100) | Завдання                                                                                                                            | Опис                                                                                                                                                                                                                                                                                            |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **100**           | **[ ] Централізувати мутації стану через єдиний сервіс**                                                                            | **Проблема:** Існує два шляхи зміни стану (`gameStateMutator` і методи в `gameState`). **Рішення:** Видалити всі методи-мутатори з `gameState.ts` (`addPlayer`, `updateSettings` і т.д.) і перенести їх логіку в `gameStateMutator` або новий `gameService`. `gameState` має стати "тупим" стором, який можна змінювати лише ззовні. |
| **95**            | **[ ] Створити більш специфічні методи в `gameStateMutator`**                                                                       | **Проблема:** Метод `applyMove` є занадто загальним. **Рішення:** Замінити `applyMove` на більш конкретні, орієнтовані на дії, методи: `movePlayer(direction, distance)`, `claimNoMoves()`, `endTurn()`. Це зробить потік даних більш прозорим і керованим.                                    |
| **90**            | **[ ] Винести логіку керування грою в `GameOrchestrator`**                                                                           | **Проблема:** Зараз логіка розкидана між компонентами та мутатором. **Рішення:** Створити сервіс `GameOrchestrator`, який буде слухати дії гравця (з UI), викликати відповідні методи `gameStateMutator` та керувати черговістю ходів, перевіркою на кінець гри і т.д. Це повністю ізолює логіку. |
| **80**            | **[ ] Рефакторинг методів `addPlayerBonus` та `addPlayerPenalty`**                                                                    | **Проблема:** Дублювання коду. **Рішення:** Створити єдиний приватний метод, наприклад `updatePlayerScore(playerId, points, historyEntry)`, щоб усунути дублювання.                                                                                                                            |
| **70**            | **[ ] Створити чіткий інтерфейс для ігрових режимів (`GameMode`)**                                                                   | **Проблема:** Для додавання онлайн-режиму потрібна чітка структура. **Рішення:** Визначити TypeScript інтерфейс `IGameMode`, який буде реалізований класами `LocalGameMode`, `VsComputerMode`, `OnlineGameMode`. Оркестратор буде використовувати поточний режим для обробки дій.          |
