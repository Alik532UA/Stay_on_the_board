Звісно. Створення якісної документації — це інвестиція в майбутнє проєкту. Це допоможе вам (і будь-яким іншим розробникам) швидко орієнтуватися в кодовій базі, розуміти архітектурні рішення та вносити зміни з меншим ризиком щось зламати.

Ось детальний план, розбитий на три логічні кроки.

---

### Детальний План: Створення та Покращення Документації

**Мета:** Створити централізований документ, що описує архітектуру, та доповнити код JSDoc-коментарями для покращення читабельності та підтримки IntelliSense.

---

### Крок 1: Створення `ARCHITECTURE.md`

Цей файл буде вашим головним довідником по архітектурі проєкту.

1.  **Створіть файл:** `docs/ARCHITECTURE.md`

2.  **Додайте до нього наступну структуру та зміст.** Це шаблон, який ви можете доповнити та адаптувати.

    ```markdown
    # Архітектура Проєкту "Stay on the Board"

    Цей документ описує основні архітектурні принципи, структуру стану та потік даних у застосунку.

    ## 1. Ключові Принципи

    - **Single Source of Truth (SSoT):** Весь логічний стан гри зберігається в `gameState`. Інші стани (UI, налаштування) зберігаються у власних спеціалізованих сторах. Похідні дані обчислюються за допомогою `derived` сторів.
    - **Unidirectional Data Flow (UDF):** Потік даних є односпрямованим:
      1.  **UI (Компонент)** викликає дію з **`GameOrchestrator`**.
      2.  **`GameOrchestrator`** викликає чисті функції-мутатори з **`GameLogicService`**.
      3.  **`GameLogicService`** оновлює **`gameState`**.
      4.  **UI (Компонент)** реактивно оновлюється у відповідь на зміну стану.
    - **Separation of Concerns (SoC):** Відповідальності чітко розділені між різними модулями (стори, сервіси, компоненти).

    ## 2. Схема Потоку Даних (UDF)

    *На цьому місці ми створимо діаграму, яка візуалізує потік даних. Можна використовувати Mermaid синтаксис, який підтримується GitHub та багатьма редакторами.*

    ```mermaid
    graph TD
        subgraph "UI Layer (Components)"
            A[ControlsPanelWidget] -->|1. on:click| B(GameOrchestrator);
            C[BoardWrapperWidget] --
    >|4. subscribe| D(animationStore);
            E[MainMenu] -->|1. on:click| F(uiService);
        end

        subgraph "Service Layer"
            B -->|2. Виклик мутаторів| G(GameLogicService);
            F -->|Виклик дій| B;
            B -->|Побічні ефекти| H(AudioService);
            B -->|Побічні ефекти| I(NavigationService);
        end

        subgraph "State Layer (Stores)"
            G -->|3. update()| J[gameState];
            J -->|reacts to| K[derivedState];
            J -->|reacts to| D;
        end

        K -->|4. subscribe| A;
    ```

    ## 3. Опис Модулів

    ### 3.1. Стори (`src/lib/stores/`)

    - **`gameState.ts`**: **SSoT для ігрової логіки.** Містить все, що стосується поточної партії: розмір дошки, позицію ферзя, рахунок, історію ходів, чергу ходів для анімації (`moveQueue`).
    - **`appSettingsStore.js`**: **SSoT для налаштувань.** Зберігає вибір користувача: тема, мова, гарячі клавіші, стан чекбоксів. Зберігається в `localStorage`.
    - **`playerInputStore.js`**: Зберігає **тимчасовий** стан вводу гравця (`selectedDirection`, `selectedDistance`). Скидається після кожного ходу.
    - **`animationStore.js`**: **Сервіс-стор для візуалізації.** Підписується на `gameState.moveQueue` і відтворює анімації у власному темпі. Компоненти дошки залежать тільки від нього.
    - **`derivedState.ts`**: Містить `derived` стори, які обчислюють похідні дані (наприклад, `lastComputerMove`, `centerInfo`), щоб уникнути складної логіки в компонентах.

    ### 3.2. Сервіси (`src/lib/services/`)

    - **`gameLogicService.ts`**: **Бібліотека чистих функцій.** Містить всю логіку гри: правила (`getAvailableMoves`), мутатори стану (`resetGame`, `performMove`). Не містить побічних ефектів.
    - **`gameOrchestrator.js`**: **"Мозок" гри.** Єдина точка входу для дій гравця. Координує виклики `gameLogicService`, запускає хід комп'ютера та керує побічними ефектами (аудіо, навігація).
    - **`uiService.js`**: Містить логіку UI, не прив'язану до конкретного компонента (наприклад, логіка показу модального вікна вибору режиму при переході на `/game`).
    - **`audioService.js` / `navigationService.js` / `logService.js` / `modalService.js`**: Ізольовані сервіси для керування відповідними побічними ефектами.

    ### 3.3. Компоненти (`src/lib/components/`)

    - **Віджети (`widgets/`):** Компоненти, що є частиною ігрового екрану (`BoardWrapperWidget`, `ControlsPanelWidget` тощо). Вони є "тупими" і лише відображають дані зі сторів та викликають дії з сервісів.
    - **Загальні компоненти:** Перевикористовувані елементи, такі як `Modal.svelte`, `FloatingBackButton.svelte`.

    ```

---

### Крок 2: Додавання JSDoc-коментарів

Тепер ми пройдемося по ключових файлах і додамо JSDoc, щоб покращити автодоповнення в IDE та зробити код самодокументованим.

1.  **`src/lib/stores/gameState.ts`:**
    *   Додайте коментарі до кожного поля в інтерфейсі `GameState`, пояснюючи його призначення.

    ```typescript
    export interface GameState {
      /** Унікальний ідентифікатор поточної гри, змінюється при кожному перезапуску. */
      gameId: number;
      /** Поточний розмір дошки (наприклад, 4 для 4x4). */
      boardSize: number;
      // ... і так далі для кожного поля
    }
    ```

2.  **`src/lib/services/gameLogicService.ts`:**
    *   Додайте JSDoc до кожної експортованої функції, описуючи, що вона робить, її параметри (`@param`) та що вона повертає (`@returns`).

    ```typescript
    /**
     * Скидає гру до початкового стану. Можна вказати новий розмір дошки.
     * Це єдина точка входу для старту нової гри.
     * @param {object} [options] - Опціональні параметри.
     * @param {number} [options.newSize] - Новий розмір дошки.
     */
    export function resetGame(options: { newSize?: number } = {}) { /* ... */ }
    ```

3.  **`src/lib/gameOrchestrator.js`:**
    *   Додайте загальний коментар до сервісу, описуючи його роль.
    *   Додайте JSDoc до кожного публічного методу (`confirmPlayerMove`, `claimNoMoves` тощо).

    ```javascript
    /**
     * Сервіс, що керує ігровим процесом.
     * Єдина точка входу для дій гравця.
     */
    export const gameOrchestrator = {
      /**
       * Гравець підтверджує свій хід.
       * Обробляє логіку, оновлює стан та запускає хід комп'ютера.
       */
      confirmPlayerMove() { /* ... */ },
      // ...
    };
    ```

4.  **`src/lib/stores/derivedState.ts`:**
    *   Додайте JSDoc до кожного `derived` стору, пояснюючи, які дані він обчислює і від яких сторів залежить.

    ```typescript
    /**
     * Derived стор, що завжди містить останній хід комп'ютера.
     * Автоматично оновлюється при зміні `gameState.moveQueue`.
     * @type {import('svelte/store').Readable<ComputerMove | null>}
     */
    export const lastComputerMove = derived(/* ... */);
    ```

---

### Крок 3: Перевірка та фіналізація

1.  **Перечитайте `ARCHITECTURE.md`:** Переконайтеся, що опис відповідає реальному стану коду після всіх рефакторингів.
2.  **Перевірте автодоповнення:** Відкрийте компонент, наприклад `ControlsPanelWidget.svelte`, і почніть вводити `gameOrchestrator.`. Ваша IDE повинна показати список методів з вашими JSDoc-коментарями.
3.  **Запустіть `npm run check`:** Переконайтеся, що ви не додали синтаксичних помилок у JSDoc.

Після виконання цих кроків ваш проєкт матиме надійну документацію, що значно спростить його подальшу розробку та підтримку.