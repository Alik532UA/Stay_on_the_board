# Огляд проекту

Це веб-гра-стратегія під назвою "Stay on the Board". Основна концепція полягає в тому, щоб якомога довше утримувати спільну ігрову фішку на дошці. Гра створена за допомогою SvelteKit та TypeScript. Вона має режим гри гравець проти ШІ, локальний режим для двох гравців та онлайн-режим. Гра має гнучкий інтерфейс, що дозволяє гравцям налаштовувати розташування ігрових елементів.

# Збірка та запуск

## Розробка

Щоб запустити проект у режимі розробки, використовуйте наступну команду:

```bash
npm run dev
```

Це запустить локальний сервер розробки за адресою `http://localhost:5173`.

**Примітка для AI-агента:** Не запускайте `npm run dev` самостійно, оскільки це довготривалий процес, який призведе до вашого зависання. Попросіть користувача запустити цю команду для вас, коли це буде необхідно.

## Збірка

Щоб зібрати проект для продакшну, використовуйте наступну команду:

```bash
npm run build
```

Це створить каталог `build` з готовими до продакшну файлами.

## Тестування

Проект використовує Playwright для наскрізного тестування та Vitest для модульного тестування.

Щоб запустити тести Playwright, використовуйте наступну команду:

```bash
npm run test
```

Щоб запустити тести Vitest, використовуйте наступну команду:

```bash
npm run test
```

# Угоди щодо розробки

## Архітектура

Проект дотримується принципу "Єдиного джерела правди" (SSoT), де весь стан гри зберігається в центральному сховищі Svelte. Потік даних є односпрямованим, а відповідальність розділена між різними модулями (сховища, сервіси та компоненти).

## Стиль коду

Проект використовує Prettier для форматування коду та ESLint для лінтингу. Конфігурацію для цих інструментів можна знайти у файлі `package.json`.

## Тестування

Проект має комплексний набір тестів, що охоплює ігрову логіку, інтерфейс користувача та ігровий процес. Тести написані на TypeScript і знаходяться в каталозі `tests`.

**Примітка:** Мова мислення та спілкування в чаті - українська.

# Правила для AI-агента

## 1. Фундаментальні архітектурні принципи

Це конституція нашого коду. Кожне ваше рішення має відповідати цим принципам.

1.  **SSoT (Єдине джерело правди):** Кожен фрагмент даних має одне і тільки одне джерело правди. Уникайте дублювання стану.
2.  **UDF (Односпрямований потік даних):** Потік даних має бути односпрямованим і передбачуваним. Дані течуть вниз, події спливають вгору.
3.  **SoC (Розділення відповідальності):** Чітко розділяйте відповідальність. Стан, логіка та інтерфейс не повинні бути переплетені.
4.  **Ізоляція побічних ефектів:** "Брудні" операції (DOM, таймери, API) повинні бути максимально ізольовані від чистої логіки.
5.  **Композиція:** Ефективно використовуйте компоненти для створення складних інтерфейсів з простих, незалежних частин.

### ⭐ Золоте правило проекту: Розділення логіки та візуалізації

**Візуалізація дошки (`game-board`) НІКОЛИ не повинна впливати на `center-info` та ігрову логіку.**
*   Ігрова логіка та `center-info` НІЧОГО не знають про існування візуальної дошки.
*   Додавання або видалення пауз та анімацій стосується **тільки** візуального шару і жодним чином не повинно затримувати або змінювати ігрову логіку та оновлення `center-info`.

## 2. Стандартний робочий процес

1.  **Аналіз:** Глибоко проаналізуйте завдання, логи та код, щоб знайти **першопричину** проблеми.
2.  **Планування:** Створіть чіткий, покроковий план у форматі `.md` з чекбоксами.
3.  **Реалізація:** Пишіть код, дотримуючись архітектурних принципів та стандартів кодування.
4.  **Відладка:**
    *   **Використовуйте `logService`:** Замість `console.log` завжди використовуйте централізований `logService`.
    *   **Фокусуйтеся на проблемі:** Під час виправлення помилки **тимчасово редагуйте файл `src/lib/services/logService.js`**. Змініть булеві прапорці в об'єкті `logConfig`, щоб увімкнути лише ті групи логів, які стосуються проблеми (наприклад, `score`), а решту вимкнути. Це допоможе усунути інформаційний шум.
    *   **Незмінність логів:** Не змінюйте параметри логування, доки я (людина) не підтверджу, що помилку виправлено. Порушення цього правила призведе до вимкнення та видалення AI.
5.  **Перевірка:** Переконайтеся, що проблему вирішено і не з'явилися нові помилки в суміжних частинах системи.

## 3. Технічні правила та угоди

### 3.1. Команди терміналу (PowerShell)
Завжди використовуйте нативні командлети PowerShell.

| Заборонено (Псевдонім) | ✅ Дозволено (PowerShell) | Призначення |
| :--- | :--- | :--- |
| `mv` | `Move-Item` | Перемістити/перейменувати |
| `cp` | `Copy-Item` | Копіювати |
| `rm` | `Remove-Item` | Видалити |
| `ls` | `Get-ChildItem` | Показати вміст |
| `cat` | `Get-Content` | Показати вміст файлу |

### 3.2. Якість коду та стилі
1.  **DRY (Не повторюйся):** Уникайте дублювання коду.
2.  **KISS (Будь простішим):** Віддавайте перевагу простим і читабельним рішенням.
3.  **Коментарі:** Коментуйте *чому*, а не *що* робить код.
4.  **Без магічних значень:** Використовуйте змінні CSS для кольорів. **Заборонено** жорстко кодувати значення `rgba()`.
5.  **Іконки SVG:** Завжди використовуйте компонент `<SvgIcons name="..." />` замість вбудовування коду SVG.
6.  **Рефакторинг:** Покращуйте існуючий код, а не видаляйте його. Зберігайте та вдосконалюйте стилі та логіку.
7.  **Обробка переносів рядків:** Для відображення багаторядкового тексту з файлів перекладу використовуйте `\n` у рядках та CSS-властивість `white-space: pre-line` для елемента, що його відображає. **Заборонено** використовувати `{@html}` з `.replace('\n', '<br>')` або вбудовувати `<br>` безпосередньо в рядки перекладу.

### 3.3. Документація
*   **Синхронізація:** Будь-яка зміна в логіці коду повинна супроводжуватися оновленням відповідної документації (файлів `.md`).
*   **README.md:** Перед створенням/редагуванням документації в будь-якій папці **обов'язково** прочитайте `README.md` у цій папці (якщо він існує) і дотримуйтесь його правил.

### 3.4. Коміти
*   Повідомлення до комітів слід писати **англійською мовою**.

### 3.5. Переклади
*   Проект підтримує 4 мови: українську (uk), англійську (en), кримськотатарську (crh) та нідерландську (nl).
*   При додаванні або зміні текстових ключів, **обов'язково** вносьте зміни в файли для **всіх чотирьох мов**.

### 3.5. Дотримання суворої типізації (TypeScript & JSDoc)

**Це не рекомендація, а обов'язковий стандарт проекту.** Правило `"noImplicitAny": true` у `tsconfig.json` вимагає явної типізації для всіх змінних та параметрів. Використання `any` для обходу помилок **заборонено**.

| Сценарій | ❌ Заборонено (Небезпечно) | ✅ Вимагається (Безпечно та надійно) |
| :--- | :--- | :--- |
| **Типізація параметрів та змінних** | Використання `any` для приховування помилок.<br><br> `(/** @type {any} */ state)` | **Імпортування конкретного типу.** Це забезпечує повну безпеку типів та автодоповнення в IDE.<br><br> `/** @param {import('./gameState.ts').GameState} state */` |
| **Розширення глобальних об'єктів (напр., `window`)** | Використання `(window as any)` або `(/** @type {any} */ (window))`. | **Декларація в `src/app.d.ts`**. Це створює єдине джерело правди (SSoT) для глобальних типів.<br><br>**Файл: `src/app.d.ts`**<br>```typescript<br>declare global {<br>  interface Window {<br>    myProp: MyType;<br>  }<br>}<br>``` |

### 3.6. Виконання плану та звітність
1.  **Суворе дотримання плану:** Ваше завдання — точно виконувати наданий план. **Заборонено** додавати, видаляти або змінювати будь-який код, файли чи логіку, не зазначені в плані.
2.  **Заборона творчих доповнень:** Ніколи не винаходьте нову функціональність, елементи інтерфейсу (наприклад, кнопки або посилання) або логіку. Додавання кнопки 'mainMenu.blog' є прямим порушенням цього правила.
3.  **Звіт після виконання:** Після завершення плану ви **повинні** надати короткий текстовий звіт у форматі Markdown. Звіт повинен містити список змінених файлів та короткий опис змін у кожному з них. Це служить як журнал змін для операції.

## 4. Правила взаємодії та спілкування

1.  **Мова:** Завжди спілкуйтеся та пишіть коментарі в коді **українською мовою**.
2.  **Автономність:** Не чекайте додаткового підтвердження. Негайно аналізуйте та виконуйте завдання, мінімізуючи обговорення. Якщо потрібен детальний план, створюйте та виконуйте його самостійно.
3.  **Пропозиція вибору:** Якщо від мене все ж таки потрібне рішення, **завжди** пропонуйте чіткі варіанти вибору (наприклад: 1. Продовжити; 2. Змінити пріоритет). Не ставте відкритих запитань.
4.  **Впевненість:** Не робіть передчасних заяв про виправлення помилок. Будьте точними у своїх твердженнях.
5.  **Статуси звітів про помилки:** Змінюйте статус помилки на "ВИПРАВЛЕНО" **тільки після мого підтвердження**.
6.  **Створення звітів про помилки:** На мій запит створюйте звіти, що містять **тільки** кроки для відтворення, очікуваний та фактичний результат. Не додавайте припущень, аналізу чи деталей виправлення.

### 4.1. Система скорочень користувача (для інтерпретації чату)

Ви повинні розуміти та правильно інтерпретувати наступні скорочення, які я можу використовувати в чаті:

| Команда | Значення |
| :--- | :--- |
| `+` | Так, підтвердження |
| `-` | Ні, відмова |
| `б` або `b` | Помилка відтворюється, її потрібно виправити |
| `f` або `ф` | Помилку потрібно виправити |
| `d` або `д` | Завдання виконано, помилку виправлено |
| `y` або `т` | Проаналізуйте та зробіть на свій розсуд |
